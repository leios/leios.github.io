<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>A &#39;Fragment Shader&#39; · Leios Labs</title><meta name="title" content="A &#39;Fragment Shader&#39; · Leios Labs"/><meta property="og:title" content="A &#39;Fragment Shader&#39; · Leios Labs"/><meta property="twitter:title" content="A &#39;Fragment Shader&#39; · Leios Labs"/><meta name="description" content="Documentation for Leios Labs."/><meta property="og:description" content="Documentation for Leios Labs."/><meta property="twitter:description" content="Documentation for Leios Labs."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Leios Labs logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Leios Labs</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">General Information</a></li><li><a class="tocitem" href="../../content/about/">About Me</a></li><li><span class="tocitem">Quibble Docs</span><ul><li><a class="tocitem" href="../">Welcome</a></li><li><a class="tocitem" href="../justification/">Design Justifications</a></li><li><a class="tocitem" href="../workflow/">General Overview</a></li><li class="is-active"><a class="tocitem" href>A &#39;Fragment Shader&#39;</a><ul class="internal"><li><a class="tocitem" href="#Step-1:-Our-first-quibble-scribble"><span>Step 1: Our first quibble scribble</span></a></li><li><a class="tocitem" href="#Step-2:-Building-the-program"><span>Step 2: Building the program</span></a></li><li><a class="tocitem" href="#Step-3:-Defining-the-output-format"><span>Step 3: Defining the output format</span></a></li><li><a class="tocitem" href="#Conclusions"><span>Conclusions</span></a></li></ul></li></ul></li><li><span class="tocitem">GPU Kernel Handbook</span><ul><li><a class="tocitem" href="../../gpu-handbook/">Welcome</a></li><li><a class="tocitem" href="../../gpu-handbook/reviewers/">Reviewer Guidelines</a></li><li><a class="tocitem" href="../../gpu-handbook/about_me/">About the Author</a></li><li><a class="tocitem" href="../../gpu-handbook/intro/">Introduction</a></li><li><a class="tocitem" href="../../gpu-handbook/abstractions/">All the Ways to GPU</a></li></ul></li><li><span class="tocitem">Scribblings</span><ul><li><a class="tocitem" href="../../scribbleios/">Welcome</a></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">2024</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../scribbleios/2024/September/28/">A Second Chance</a></li><li><a class="tocitem" href="../../scribbleios/2024/February/20/">The Livestreaming Accident</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">2023</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../scribbleios/2023/2023/">The Read Message</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-4" type="checkbox"/><label class="tocitem" for="menuitem-5-4"><span class="docs-label">2022</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../scribbleios/2022/August/01/">The Commute</a></li><li><a class="tocitem" href="../../scribbleios/2022/May/10/">The USB Hero</a></li><li><a class="tocitem" href="../../scribbleios/2022/April/11/">The Modern Blacksmith</a></li><li><a class="tocitem" href="../../scribbleios/2022/April/07/">The Humbler</a></li><li><a class="tocitem" href="../../scribbleios/2022/March/30/">The Conscious Actor</a></li><li><a class="tocitem" href="../../scribbleios/2022/February/24/">Digital Selves</a></li><li><a class="tocitem" href="../../scribbleios/2022/February/15/">Walking to School</a></li><li><a class="tocitem" href="../../scribbleios/2022/February/11/">Wikipedia: Peter Shelly</a></li><li><a class="tocitem" href="../../scribbleios/2022/February/02/">Bittersweet Memories</a></li><li><a class="tocitem" href="../../scribbleios/2022/February/01/">Academic Correspondences</a></li><li><a class="tocitem" href="../../scribbleios/2022/January/31/">The Beowulf Poet</a></li><li><a class="tocitem" href="../../scribbleios/2022/January/23/">A Waste of Time</a></li><li><a class="tocitem" href="../../scribbleios/2022/January/02/">Describing a Tree</a></li><li><a class="tocitem" href="../../scribbleios/2022/January/06/">The Future</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-5" type="checkbox"/><label class="tocitem" for="menuitem-5-5"><span class="docs-label">2021</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../scribbleios/2021/December/12/">The NPC</a></li><li><a class="tocitem" href="../../scribbleios/2021/February/03/">A Talentless Student</a></li><li><a class="tocitem" href="../../scribbleios/2021/February/02/">The Master&#39;s Disciple</a></li><li><a class="tocitem" href="../../scribbleios/2021/February/01/">The Potion Master</a></li><li><a class="tocitem" href="../../scribbleios/2021/January/31/">The G00Gl3 Interview</a></li><li><a class="tocitem" href="../../scribbleios/2021/January/30/">A Mother&#39;s Love</a></li><li><a class="tocitem" href="../../scribbleios/2021/January/29/">The Creation Machine</a></li><li><a class="tocitem" href="../../scribbleios/2021/January/28/">The Great Collapse</a></li><li><a class="tocitem" href="../../scribbleios/2021/January/27/">Losing Myself</a></li><li><a class="tocitem" href="../../scribbleios/2021/January/26/">Merfolk</a></li><li><a class="tocitem" href="../../scribbleios/2021/January/22/">The Super Couple</a></li><li><a class="tocitem" href="../../scribbleios/2021/January/03/">The Girlfriend</a></li><li><a class="tocitem" href="../../scribbleios/2021/January/02/">The Anti-Poem</a></li><li><a class="tocitem" href="../../scribbleios/2021/January/01/">Who I Want to Be</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-6" type="checkbox"/><label class="tocitem" for="menuitem-5-6"><span class="docs-label">2020</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../scribbleios/2020/December/27/">Reincarnated Happiness</a></li><li><a class="tocitem" href="../../scribbleios/2020/December/26/">The Helpful Demon</a></li><li><a class="tocitem" href="../../scribbleios/2020/December/25/">Sophia and Aheb</a></li><li><a class="tocitem" href="../../scribbleios/2020/December/24/">Age Regression</a></li><li><a class="tocitem" href="../../scribbleios/2020/December/23/">Shy Gal</a></li><li><a class="tocitem" href="../../scribbleios/2020/December/12/">This is Not the End</a></li><li><a class="tocitem" href="../../scribbleios/2020/December/11/">All the Right Questions</a></li><li><a class="tocitem" href="../../scribbleios/2020/December/10/">Returning to the Sea</a></li><li><a class="tocitem" href="../../scribbleios/2020/December/09/">How Elves are Made</a></li><li><a class="tocitem" href="../../scribbleios/2020/December/08/">The American Hero</a></li><li><a class="tocitem" href="../../scribbleios/2020/December/07/">Jim</a></li><li><a class="tocitem" href="../../scribbleios/2020/December/06/">The Cult of Vi</a></li><li><a class="tocitem" href="../../scribbleios/2020/December/05/">Rhyming Truths</a></li><li><a class="tocitem" href="../../scribbleios/2020/December/04/">The Blind Dragon</a></li><li><a class="tocitem" href="../../scribbleios/2020/December/03/">Santa Stole the Money</a></li><li><a class="tocitem" href="../../scribbleios/2020/December/02/">The Angel of Mercy</a></li><li><a class="tocitem" href="../../scribbleios/2020/December/01/">The Genie Order</a></li><li><a class="tocitem" href="../../scribbleios/2020/November/30/">The Bargaining Protagonist</a></li><li><a class="tocitem" href="../../scribbleios/2020/November/29/">Raindrops on the Window</a></li><li><a class="tocitem" href="../../scribbleios/2020/October/06/">Happy Habitat</a></li><li><a class="tocitem" href="../../scribbleios/2020/October/05/">Another Castle</a></li><li><a class="tocitem" href="../../scribbleios/2020/October/04/">Glitching</a></li><li><a class="tocitem" href="../../scribbleios/2020/October/03/">Mirrors on the Wall</a></li><li><a class="tocitem" href="../../scribbleios/2020/October/02/">The Forest Guardian</a></li><li><a class="tocitem" href="../../scribbleios/2020/October/01/">The Prince of Time</a></li><li><a class="tocitem" href="../../scribbleios/2020/July/6/">The Sword and Shield</a></li><li><a class="tocitem" href="../../scribbleios/2020/July/4/">The Unsettling Sandwich</a></li><li><a class="tocitem" href="../../scribbleios/2020/July/3/">Afraid of the Light</a></li><li><a class="tocitem" href="../../scribbleios/2020/July/2/">The Demon Professor</a></li><li><a class="tocitem" href="../../scribbleios/2020/July/1/">Tree Traversing Super Power</a></li><li><a class="tocitem" href="../../scribbleios/2020/June/30/">Luminescent Love Story</a></li><li><a class="tocitem" href="../../scribbleios/2020/June/29/">Becoming Anything</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Quibble Docs</a></li><li class="is-active"><a href>A &#39;Fragment Shader&#39;</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>A &#39;Fragment Shader&#39;</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/leios/leios.github.io" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/leios/leios.github.io/blob/main/src/quibble/example_1.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="A-Simple-Shader"><a class="docs-heading-anchor" href="#A-Simple-Shader">A Simple Shader</a><a id="A-Simple-Shader-1"></a><a class="docs-heading-anchor-permalink" href="#A-Simple-Shader" title="Permalink"></a></h1><p>In computer graphics, the term &quot;shader&quot; could mean a lot of things to a lot of people. For example, in OpenGL and Vulkan, a &quot;shader&quot; basically means &quot;A function that can be run on the GPU.&quot; The most common shaders are:</p><ul><li>Vertex Shaders: Functions that move the vertex points of different meshes around</li><li>Fragment Shaders: Functions that color pixels on the screen</li></ul><p>For this example, we will be emulating the latter behaviour. The full source code can be found <a href="https://github.com/leios/quibble/blob/main/examples/simple_shader.c">here</a>. Please refer to this file if you are ever stuck!</p><p>To start, make sure that you have quibble properly installed, as shown in the <a href="../workflow/">workflow section</a>. Once that is done, this example should be completely compilable with:</p><pre><code class="nohighlight hljs">gcc -o simple_shader simple_shader.c -lquibble</code></pre><p>But remember that if you did not <code>make install</code>, you will have to specify the path to the quibble library with <code>-L</code> and quibble include file with <code>-I</code>.</p><p>In general, every quibble program can be decomposed into a few key steps:</p><ol><li>Write the program (preferably using the <code>__poem</code>, <code>__stanza</code>, and <code>__verse</code> identifiers as mentioned in the <a href="../workflow/">workflow</a> section).</li><li>Build the program</li><li>Specify the output format</li><li>Create a camera</li><li>Set program arguments</li><li>Run the program</li><li>Output</li></ol><p>It sounds like a lot, but if I remove all the comments from <a href="https://github.com/leios/quibble/blob/main/examples/simple_shader.c">the example script</a>, it&#39;s only about 25 lines of code. Also, keep in mind, that half of that is spent on step 1. In fact, subsequent examples might omit steps 2-7 entirely unless there are important changes to keep in mind.</p><p>So, let&#39;s get to it!</p><h2 id="Step-1:-Our-first-quibble-scribble"><a class="docs-heading-anchor" href="#Step-1:-Our-first-quibble-scribble">Step 1: Our first quibble scribble</a><a id="Step-1:-Our-first-quibble-scribble-1"></a><a class="docs-heading-anchor-permalink" href="#Step-1:-Our-first-quibble-scribble" title="Permalink"></a></h2><p>There are multiple different ways to write quibble scribbles. The preferred method is to read them in from another file; however, I have also provided a macro (<code>QBINLINE</code>) to allow for users to inline the program definitions in their C files. We&#39;ll be using <code>QBINLNIE</code> for this example and in subsequent examples when it&#39;s convenient.</p><p>Now, what do we want this, specific, scribble to do? Well we probably want to color each pixel in some way. Cool. How do we do that?</p><p>We could spend an unlimited amount of time fussing about the exact details here, but I&#39;m just going to create a linear gradient along <span>$x$</span> and <span>$y$</span>, where as we move to the right, the output image becomes more red and as we move down, the output image becomes blue. Something like this:</p><p><img src="../res/example_1_out.png" alt="A simple fragment shader"/></p><p>There are a bunch of different ways to do this. The easiest is to just color our output image based on whatever array index we are working with. This example will take it one step further and define the concept of a <code>point</code> in real space that will then be transformed back into pixel space. The goal is to create a series of points such that there is exactly one point for each pixel. These will then be histogrammed to screen in order to write their color information.</p><p>So let&#39;s start!</p><h3 id="1.1:-The-data-structures"><a class="docs-heading-anchor" href="#1.1:-The-data-structures">1.1: The data structures</a><a id="1.1:-The-data-structures-1"></a><a class="docs-heading-anchor-permalink" href="#1.1:-The-data-structures" title="Permalink"></a></h3><p>For this example, we&#39;ll need pixels with color information and we&#39;ll need some method to convert real space coordinates into pixel coordinates. We can dig into these in more detail later, but for now, let&#39;s just think about the types:</p><ol><li><code>quibble_color_rgba888</code> / <code>quibble_color_rgba8888</code>: These are colors used by quibble and can be either RGB (red, green, blue) or RGBA (red, green, blue, alpha). The <code>888</code> and <code>8888</code> correspond to the size of each channel of <code>R</code>, <code>G</code>, <code>B</code>, or <code>A</code>. Right now, these are the only supported color types.</li><li><code>quibble_point_nD</code>, where <code>n</code> is the dimension. These are just <span>$x$</span>, <span>$y$</span>, <span>$z$</span> floats to hold real space values.</li><li><code>quibble_pixels_rgb888</code> / <code>quibble_pixels_rgba8888</code>: These are seemingly simple types that hold pixel data as either <code>RGB888</code> or <code>RGBA8888</code>s. There&#39;s a bit more going on under-the-hood, but you (the user) shouldn&#39;t have to worry too much about it.</li><li><code>quibble_simple_camera</code>: This is a simple struct to hold all the information necessary to transform real space coordinates into pixel space.</li></ol><p>I think that&#39;s all we need to know for now.</p><h3 id="1.2.-The-functions"><a class="docs-heading-anchor" href="#1.2.-The-functions">1.2. The functions</a><a id="1.2.-The-functions-1"></a><a class="docs-heading-anchor-permalink" href="#1.2.-The-functions" title="Permalink"></a></h3><p>Keep in mind that each quibble scribble is executed as a GPU kernel. This means that we each scribble will always have access to the internal index of each thread with the <code>_idx</code> variable. So, it would seem we need the following functions:</p><ol><li><code>qb_find_point_location(_idx, cam)</code>: This will give us a floating-point representation of where each pixel is located.</li><li><code>qb_color_rgba8888(0,0,0,1)</code>: This will create a non-transparent black color to work with. If you want a different starting color, you can modify the <code>(0,0,0,1)</code> to be whatever you like. They stand for red, green, blue, and alpha and range from 0 to 1.</li><li><code>qb_color_clamp(value, 0, 1)</code>: This will convert a floating point value (ideally between 0 and 1) into something that will fit into <code>RGB888</code> or <code>RGBA8888</code>.</li><li><code>histogram_output_rgba8888(pt, color, cam, pixels)</code>: This will histogram everything to screen and convert our floating point positions back into an integer index before coloring the specified pixel.</li></ol><h3 id="1.3.-On-@include"><a class="docs-heading-anchor" href="#1.3.-On-@include">1.3. On <code>@include</code></a><a id="1.3.-On-@include-1"></a><a class="docs-heading-anchor-permalink" href="#1.3.-On-@include" title="Permalink"></a></h3><p>Now, where are these data structures and functions defined? Well, in other scribbles. Quibble scribbles are scripts and can include other scripts, and for this example, we will use:</p><pre><code class="nohighlight hljs">@include &quot;QB/simple_shader.qbl&quot;</code></pre><p>Where <code>QB</code> is the install location of all the quibble scripts (<code>XDG_CONFIG_HOME</code> or <code>/home/username/.config/quibble</code>). When you ran <code>cmake</code> earlier, the <code>configure</code> command was also run to move all the files to the right place. Otherwise, you can use local directories. If you choose to do this, it&#39;s important to note what path you are building your program in so the files can be found!</p><h3 id="1.4.-All-together"><a class="docs-heading-anchor" href="#1.4.-All-together">1.4. All together</a><a id="1.4.-All-together-1"></a><a class="docs-heading-anchor-permalink" href="#1.4.-All-together" title="Permalink"></a></h3><p>Right. I think that&#39;s everything. The final block of code will look something like this:</p><pre><code class="nohighlight hljs">#include &quot;quibble.h&quot;

int main(void){
   ...
    char *program = QBINLINE(
        @include &quot;QB/simple_shader.qbl&quot;
        __poem simple_shader(quibble_pixels_rgba8888 qps,
                             quibble_simple_camera qcam){
            quibble_point_2D pt = qb_find_point_location(_idx, qcam);
            quibble_color_rgba8888 qcolor = qb_color_rgba8888(0,0,0,1);

            qcolor.red = qb_color_clamp(
                (pt.x - qcam.world_position_x) / qcam.world_size_x,
                0, 1
            );

            qcolor.blue = qb_color_clamp(
                (pt.y - qcam.world_position_y) / qcam.world_size_y,
                0, 1
            );

            histogram_output_rgba8888(pt, qcolor, qcam, qps);
        }
    );
    ...
}</code></pre><p>As a reminder, the <code>__poem</code> keyword essentially prescribes the final kernel to be run. In other words, it&#39;s the top-level of a quibble scribble.</p><h2 id="Step-2:-Building-the-program"><a class="docs-heading-anchor" href="#Step-2:-Building-the-program">Step 2: Building the program</a><a id="Step-2:-Building-the-program-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2:-Building-the-program" title="Permalink"></a></h2><p>Luckily, all subsequent steps are much easier. Building, for example, only involves two commands. Here&#39;s the first:</p><pre><code class="nohighlight hljs">quibble_program qp = qb_parse_program(program, &quot;&quot;);</code></pre><p>Here, we are reading in the program string as <code>program</code> and setting the path to expand all scribbles on. For this example, it&#39;s set to be <code>&quot;&quot;</code> because our scribbles are being pulled from the global <code>QB/</code> directory.</p><p>The second command is a little trickier and requires us to have some knowledge of our system. In particular, we need to know <em>which device we want to run our code on</em>. To get this information, we need to run the associated <code>qbinfo</code> command. For me, it outputs the following:</p><pre><code class="nohighlight hljs">Platform 0: Intel(R) OpenCL. 1 known device(s)...
	Device 0: AMD Ryzen 7 7700X 8-Core Processor             
Platform 1: AMD Accelerated Parallel Processing. 2 known device(s)...
	Device 0: gfx1031
	Device 1: gfx1036</code></pre><p>In quibble, we need to specify both the <code>platform</code> and <code>device</code>. For me, if I want CPU execution, I&#39;ll run with <code>platform = 0</code> and <code>device = 0</code>. For GPU execution, I would run with <code>platform = 1</code> and <code>device = 0</code>.</p><p>So after parsing our program, we need to configure it with this information, like so:</p><pre><code class="nohighlight hljs">    qb_configure_program(&amp;qp, device, platform);</code></pre><p>But that&#39;s it. Once we&#39;ve run these commands, we have built our program and are ready to move on to the next step!</p><h2 id="Step-3:-Defining-the-output-format"><a class="docs-heading-anchor" href="#Step-3:-Defining-the-output-format">Step 3: Defining the output format</a><a id="Step-3:-Defining-the-output-format-1"></a><a class="docs-heading-anchor-permalink" href="#Step-3:-Defining-the-output-format" title="Permalink"></a></h2><p>Quibble provides a data structure known as <code>quibble_pixels</code>, which essentially boils down to a pair of arrays of pixels (stored as, for example, a <code>quibble_color_rgba8888</code>). I say a &quot;pair of arrays&quot; because there are technically two sets of pixels, one for the &quot;host&quot; (CPU) and another for the &quot;device&quot; (GPU, for example). Traditionally, the allocation of data on the device is a bit of a chore, but we are hiding away a lot of that complexity with this struct. For now, all we need to do is define the output resolution and specify our color type:</p><pre><code class="nohighlight hljs">    int width = 1920;
    int height = 1080;
    quibble_pixels qpix = 
        qb_create_pixel_array(qp, width, height, RGBA8888);
</code></pre><h3 id="Step-4:-Creating-a-camera"><a class="docs-heading-anchor" href="#Step-4:-Creating-a-camera">Step 4: Creating a camera</a><a id="Step-4:-Creating-a-camera-1"></a><a class="docs-heading-anchor-permalink" href="#Step-4:-Creating-a-camera" title="Permalink"></a></h3><p>In quibble, a &quot;camera&quot; is essentially a method to transform points in real space to the integer indices necessary to manipulate the <code>quibble_pixels</code>. In principle, this transformation can be from <span>$n$</span>-dimensional space to pixel space, but for this exercise, we will be using the <code>quibble_simple_camera</code>, which is exclusively in 2D. To do this, we define 3 different variables:</p><ol><li><code>world_size_x</code> / <code>world_size_y</code>: These are real space units to map the pixels on to. For example, one might say that they want their 1920 x 1080 image to span 4 x 2.25 real space units.</li><li><code>world_position_x</code> / <code>world_position_y</code>: These are the locations of the origin of the &quot;world.&quot;</li><li><code>ppu</code>: These are the &quot;points per unit&quot;, or &quot;pixels per unit&quot;. These are roughly equivalent to DPI (Dots Per Inch) for printing and correspond to the number of points in each real space distance of 1. For example, if the <code>world_size</code> is 4 and we want that to span 1920 pixels, we might say that our <code>ppu = 1920 / world_size = 1920 / 4 = 480</code>.</li></ol><p>Altogether, it might look like:</p><pre><code class="nohighlight hljs">    float world_size_x = 4;
    float ppu = width / world_size_x;
    float world_size_y = height/ppu;

    float world_position_x = 0;
    float world_position_y = 0;

    quibble_simple_camera qcam = qb_create_simple_camera(ppu,
                                                         world_size_x,
                                                         world_size_y,
                                                         world_position_x,
                                                         world_position_y);</code></pre><h3 id="Step-5:-Setting-arguments"><a class="docs-heading-anchor" href="#Step-5:-Setting-arguments">Step 5: Setting arguments</a><a id="Step-5:-Setting-arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Step-5:-Setting-arguments" title="Permalink"></a></h3><p>Ok. I&#39;ll admit that this is a weird one. After all, if you define a function <span>$f(x)$</span>, then you don&#39;t <em>usually</em> need to set <span>$x$</span> before invoking the function. In principle, there might be a future incarnation of quibble that allows us to simply launch each quibble scribble as a normal function. In practice (today), I am following the OpenCL convention of setting the arguments manually before launching the kernel. Personally, I prefer it this way, as it allows me to set all my arguments up front and then only change specific arguments as they are needed during my main animation or game loop; however, I 100% acknowledge that this is not a typical design approach outside of GPU computing / graphics.</p><p>No matter the case, I&#39;ve tried to make the process of setting function arguments to be as painless as possible and have provided a few different methods to do so. For this example, we will be using a C-style variadic function that takes <span>$2n + 3$</span> arguments, where <span>$n$</span> is the number of arguments we wish to set. For example, let&#39;s look at the code we need for this case:</p><pre><code class="nohighlight hljs">    qb_set_args(&amp;qp, &quot;simple_shader&quot;, 2,
                &quot;quibble_pixels_rgba8888 qps&quot;, qpix,
                &quot;quibble_simple_camera qcam&quot;, &amp;qcam);
</code></pre><p>The arguments are:</p><ol><li>The program</li><li>The poem we are configuring.</li><li>The number of arguments we wish to set</li></ol><p>Then a repeating pair of:</p><ol><li>The argument (and type information) specified in the poem.</li><li>The data for that argument.</li></ol><p>Note that something weird is happening here. For <code>quibble_pixels_rgba8888 qps</code>, we are reading in <code>qps</code>, but for <code>quibble_simple_camera qcam</code>, we are reading in <code>&amp;qcam</code>. In the first case, we are using the variable directly. In the latter case, we are using the pointer to a variable. What gives?</p><p>This is because <code>quibble_pixels_...</code> are actually meta-variables and will unroll into a set of variables when we configure(d) our program. That is to say we get a few variables with <code>quibble_pixels_...</code>:</p><ol><li><code>__global quibble_color_... var_name</code>: This is the actual data we are working with.</li><li><code>int var_name_width</code> / <code>int var_name_heignt</code>: These are the <code>width</code> and <code>height</code> specified by the user.</li><li><code>int var_name_color_type</code>: This is either <code>RGBA888</code> or <code>RGBA8888</code> depending on the situation and can be used to ensure we are outputting data in the correct format.</li></ol><div class="admonition is-info"><header class="admonition-header">Jank alert</header><div class="admonition-body"><p>I&#39;ve since realized that we can hold almost all of this information in our <code>camera</code> and might remove this in the future. This actually won&#39;t change anything on the front-end for most users. It&#39;s just an internal detail.</p></div></div><h3 id="Step-6:-Running-the-program"><a class="docs-heading-anchor" href="#Step-6:-Running-the-program">Step 6: Running the program</a><a id="Step-6:-Running-the-program-1"></a><a class="docs-heading-anchor-permalink" href="#Step-6:-Running-the-program" title="Permalink"></a></h3><p>If steps 1-5 were done correctly, this <em>should</em> be as easy as:</p><pre><code class="nohighlight hljs">    qb_run(qp, &quot;simple_shader&quot;, width*height, 256);</code></pre><p>But there are some &quot;magic numbers&quot; here. The arguments for this function are:</p><ol><li>The program</li><li>The poem to run (that is fully configured at this stage)</li><li>The number of threads to run in parallel (here set to <code>width*height</code>, as that is the number of pixels we want</li><li>The <code>workgroupsize</code>, which is the number of threads we want in each block</li></ol><p>Right now, 4 is set to be 256, which is a nice heuristic for GPU computation, but can be set somewhat arbitrarily.</p><div class="admonition is-info"><header class="admonition-header">Jank alert</header><div class="admonition-body"><p>I might be removing the <code>workgroupsize</code> in future incarnations of quibble. Not sure. I like having it available.</p></div></div><h3 id="Step-7:-Returning-the-data-and-saving"><a class="docs-heading-anchor" href="#Step-7:-Returning-the-data-and-saving">Step 7: Returning the data and saving</a><a id="Step-7:-Returning-the-data-and-saving-1"></a><a class="docs-heading-anchor-permalink" href="#Step-7:-Returning-the-data-and-saving" title="Permalink"></a></h3><p>At this stage, the code <em>should</em> have executed on the &quot;device&quot; (GPU). Now, we just need to send that data back and save it:</p><pre><code class="nohighlight hljs">    qb_pixels_device_to_host(qpix);
    qb_write_png_file(&quot;check.png&quot;, qpix);</code></pre><p>And then free everything:</p><pre><code class="nohighlight hljs">    qb_free_program(qp);
    qb_free_pixels(qpix);</code></pre><p>And that&#39;s it. You should have the image we are looking for saved as <code>check.png</code>. Note that there are also output functions for <code>jpg</code> and <code>bmp</code>, if you wish to use these functions instead. <code>jpg</code> will take a compression ratio as a 3rd argument that ranges from 0-100.</p><div class="admonition is-info"><header class="admonition-header">Jank alert</header><div class="admonition-body"><p>I have contemplated running <code>qb_pixels_device_to_host(qpix)</code> on every <code>qb_run(...)</code>, but have decided against it because data transfer between the host and device is always (always) the slowest part of any GPU computation and should be avoided at all costs. There are plenty of situations where users might want to keep the data on the GPU for various tasks and send the information back after a few different <code>qb_run(...)</code>s. They might even send the data to Vulkan or something and forego transferring it back to the host entirely.</p><p>Long story short, I know this looks a bit clunky, but I feel it&#39;s necessary to be explicit.</p></div></div><h2 id="Conclusions"><a class="docs-heading-anchor" href="#Conclusions">Conclusions</a><a id="Conclusions-1"></a><a class="docs-heading-anchor-permalink" href="#Conclusions" title="Permalink"></a></h2><p>So that&#39;s where we are at right now. We can create basic images without much work (25 lines). As I mentioned throughout this example, there is still a lot of room for improvement as I iron out the kinks here and there, but I am ultimately happy with how things are going. If you have specific issues you would like to discuss, please do so on <a href="https://github.com/leios/quibble/issues">github</a>. Also, again, <a href="https://github.com/leios/quibble/blob/main/examples/simple_shader.c">here is the full code</a>.</p><div class="admonition is-info"><header class="admonition-header">A simple exercise</header><div class="admonition-body"><p>Do this again, but without using the <code>point</code> data structure. Just color each pixel based on the index of the array</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../workflow/">« General Overview</a><a class="docs-footer-nextpage" href="../../gpu-handbook/">Welcome »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Sunday 27 July 2025 21:22">Sunday 27 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
