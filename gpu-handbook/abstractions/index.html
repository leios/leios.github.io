<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>All the Ways to GPU · Leios Labs</title><meta name="title" content="All the Ways to GPU · Leios Labs"/><meta property="og:title" content="All the Ways to GPU · Leios Labs"/><meta property="twitter:title" content="All the Ways to GPU · Leios Labs"/><meta name="description" content="Documentation for Leios Labs."/><meta property="og:description" content="Documentation for Leios Labs."/><meta property="twitter:description" content="Documentation for Leios Labs."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Leios Labs logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Leios Labs</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">General Information</a></li><li><a class="tocitem" href="../../content/about/">About Me</a></li><li><span class="tocitem">Quibble Docs</span><ul><li><a class="tocitem" href="../../quibble/">Welcome</a></li><li><a class="tocitem" href="../../quibble/justification/">Design Justifications</a></li></ul></li><li><span class="tocitem">GPU Kernel Handbook</span><ul><li><a class="tocitem" href="../">Welcome</a></li><li><a class="tocitem" href="../reviewers/">Reviewer Guidelines</a></li><li><a class="tocitem" href="../about_me/">About the Author</a></li><li><a class="tocitem" href="../intro/">Introduction</a></li><li class="is-active"><a class="tocitem" href>All the Ways to GPU</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Figuring-out-your-hardware"><span>Figuring out your hardware</span></a></li><li><a class="tocitem" href="#Your-first-GPU-array"><span>Your first GPU array</span></a></li><li><a class="tocitem" href="#I-have-a-GPU-array.-Now-what?"><span>I have a GPU array. Now what?</span></a></li><li><a class="tocitem" href="#GPU-Functions:-Kernels"><span>GPU Functions: Kernels</span></a></li><li><a class="tocitem" href="#A-discussion-on-loop-vectorization"><span>A discussion on loop vectorization</span></a></li></ul></li></ul></li><li><span class="tocitem">Scribblings</span><ul><li><a class="tocitem" href="../../scribbleios/">Welcome</a></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">2024</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../scribbleios/2024/September/28/">A Second Chance</a></li><li><a class="tocitem" href="../../scribbleios/2024/February/20/">The Livestreaming Accident</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">2023</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../scribbleios/2023/2023/">The Read Message</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-4" type="checkbox"/><label class="tocitem" for="menuitem-5-4"><span class="docs-label">2022</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../scribbleios/2022/August/01/">The Commute</a></li><li><a class="tocitem" href="../../scribbleios/2022/May/10/">The USB Hero</a></li><li><a class="tocitem" href="../../scribbleios/2022/April/11/">The Modern Blacksmith</a></li><li><a class="tocitem" href="../../scribbleios/2022/April/07/">The Humbler</a></li><li><a class="tocitem" href="../../scribbleios/2022/March/30/">The Conscious Actor</a></li><li><a class="tocitem" href="../../scribbleios/2022/February/24/">Digital Selves</a></li><li><a class="tocitem" href="../../scribbleios/2022/February/15/">Walking to School</a></li><li><a class="tocitem" href="../../scribbleios/2022/February/11/">Wikipedia: Peter Shelly</a></li><li><a class="tocitem" href="../../scribbleios/2022/February/02/">Bittersweet Memories</a></li><li><a class="tocitem" href="../../scribbleios/2022/February/01/">Academic Correspondences</a></li><li><a class="tocitem" href="../../scribbleios/2022/January/31/">The Beowulf Poet</a></li><li><a class="tocitem" href="../../scribbleios/2022/January/23/">A Waste of Time</a></li><li><a class="tocitem" href="../../scribbleios/2022/January/02/">Describing a Tree</a></li><li><a class="tocitem" href="../../scribbleios/2022/January/06/">The Future</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-5" type="checkbox"/><label class="tocitem" for="menuitem-5-5"><span class="docs-label">2021</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../scribbleios/2021/December/12/">The NPC</a></li><li><a class="tocitem" href="../../scribbleios/2021/February/03/">A Talentless Student</a></li><li><a class="tocitem" href="../../scribbleios/2021/February/02/">The Master&#39;s Disciple</a></li><li><a class="tocitem" href="../../scribbleios/2021/February/01/">The Potion Master</a></li><li><a class="tocitem" href="../../scribbleios/2021/January/31/">The G00Gl3 Interview</a></li><li><a class="tocitem" href="../../scribbleios/2021/January/30/">A Mother&#39;s Love</a></li><li><a class="tocitem" href="../../scribbleios/2021/January/29/">The Creation Machine</a></li><li><a class="tocitem" href="../../scribbleios/2021/January/28/">The Great Collapse</a></li><li><a class="tocitem" href="../../scribbleios/2021/January/27/">Losing Myself</a></li><li><a class="tocitem" href="../../scribbleios/2021/January/26/">Merfolk</a></li><li><a class="tocitem" href="../../scribbleios/2021/January/22/">The Super Couple</a></li><li><a class="tocitem" href="../../scribbleios/2021/January/03/">The Girlfriend</a></li><li><a class="tocitem" href="../../scribbleios/2021/January/02/">The Anti-Poem</a></li><li><a class="tocitem" href="../../scribbleios/2021/January/01/">Who I Want to Be</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-6" type="checkbox"/><label class="tocitem" for="menuitem-5-6"><span class="docs-label">2020</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../scribbleios/2020/December/27/">Reincarnated Happiness</a></li><li><a class="tocitem" href="../../scribbleios/2020/December/26/">The Helpful Demon</a></li><li><a class="tocitem" href="../../scribbleios/2020/December/25/">Sophia and Aheb</a></li><li><a class="tocitem" href="../../scribbleios/2020/December/24/">Age Regression</a></li><li><a class="tocitem" href="../../scribbleios/2020/December/23/">Shy Gal</a></li><li><a class="tocitem" href="../../scribbleios/2020/December/12/">This is Not the End</a></li><li><a class="tocitem" href="../../scribbleios/2020/December/11/">All the Right Questions</a></li><li><a class="tocitem" href="../../scribbleios/2020/December/10/">Returning to the Sea</a></li><li><a class="tocitem" href="../../scribbleios/2020/December/09/">How Elves are Made</a></li><li><a class="tocitem" href="../../scribbleios/2020/December/08/">The American Hero</a></li><li><a class="tocitem" href="../../scribbleios/2020/December/07/">Jim</a></li><li><a class="tocitem" href="../../scribbleios/2020/December/06/">The Cult of Vi</a></li><li><a class="tocitem" href="../../scribbleios/2020/December/05/">Rhyming Truths</a></li><li><a class="tocitem" href="../../scribbleios/2020/December/04/">The Blind Dragon</a></li><li><a class="tocitem" href="../../scribbleios/2020/December/03/">Santa Stole the Money</a></li><li><a class="tocitem" href="../../scribbleios/2020/December/02/">The Angel of Mercy</a></li><li><a class="tocitem" href="../../scribbleios/2020/December/01/">The Genie Order</a></li><li><a class="tocitem" href="../../scribbleios/2020/November/30/">The Bargaining Protagonist</a></li><li><a class="tocitem" href="../../scribbleios/2020/November/29/">Raindrops on the Window</a></li><li><a class="tocitem" href="../../scribbleios/2020/October/06/">Happy Habitat</a></li><li><a class="tocitem" href="../../scribbleios/2020/October/05/">Another Castle</a></li><li><a class="tocitem" href="../../scribbleios/2020/October/04/">Glitching</a></li><li><a class="tocitem" href="../../scribbleios/2020/October/03/">Mirrors on the Wall</a></li><li><a class="tocitem" href="../../scribbleios/2020/October/02/">The Forest Guardian</a></li><li><a class="tocitem" href="../../scribbleios/2020/October/01/">The Prince of Time</a></li><li><a class="tocitem" href="../../scribbleios/2020/July/6/">The Sword and Shield</a></li><li><a class="tocitem" href="../../scribbleios/2020/July/4/">The Unsettling Sandwich</a></li><li><a class="tocitem" href="../../scribbleios/2020/July/3/">Afraid of the Light</a></li><li><a class="tocitem" href="../../scribbleios/2020/July/2/">The Demon Professor</a></li><li><a class="tocitem" href="../../scribbleios/2020/July/1/">Tree Traversing Super Power</a></li><li><a class="tocitem" href="../../scribbleios/2020/June/30/">Luminescent Love Story</a></li><li><a class="tocitem" href="../../scribbleios/2020/June/29/">Becoming Anything</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">GPU Kernel Handbook</a></li><li class="is-active"><a href>All the Ways to GPU</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>All the Ways to GPU</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/leios/leios.github.io" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/leios/leios.github.io/blob/main/src/gpu-handbook/abstractions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="All-the-Ways-to-GPU"><a class="docs-heading-anchor" href="#All-the-Ways-to-GPU">All the Ways to GPU</a><a id="All-the-Ways-to-GPU-1"></a><a class="docs-heading-anchor-permalink" href="#All-the-Ways-to-GPU" title="Permalink"></a></h1><p>At the end of the day, GPUs are pieces of hardware. Complicated pieces of hardware. In fact, GPUs (and modern CPUs) are so complicated that it would be nearly impossible for an individual to directly write down a set of instructions for the hardware to run. Instead, users write code in some human-readable language like C, Rust, or Julia, which will then be translated to some other language, and then (often times) another language again and again until it becomes the final instruction set that their hardware can execute. This process is known as compilation. As a rule of thumb, the easier it is to read and write in a programming language, the more difficult the compilation process will be.</p><p>At every layer of compilation, we are further simplifying the translation process through software abstractions. Simply put, an abstraction is a metaphorical device used to make a complex task easier to understand. We use abstractions <em>everywhere</em> in programming. Examples include: <code>for</code> and <code>while</code> loops, functions, structures and classes, etc. Basically every common programming device we use is an abstraction of some form. In this chapter, I will introduce many common abstractions that can be used  to perform GPU computation, but let&#39;s start at the start.</p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>I think it is important to pause a second before jumping in to the water to remind ourselves of a simple truth: the first step of any project is always the hardest. This also holds true for programming, so if you find yourself a little lost while reading this chapter, that&#39;s totally normal. It&#39;s ok to put the book down. It&#39;s ok to ask for help. The most important thing is that you are steadily making progress towards your goals, whatever they might be.</p><p>Now let&#39;s begin.</p><p>As mentioned in the introduction, we will be using the Julia programming language for this book, so the first step is to install Julia. It is important to note that this book is intended for those who already have some (at least limited) familiarity with programming. As such, I will keep the installation instructions brief. If you are already used to programming, you probably already have your own preferred development workflows all sorted out and can just google for similar solutions with Julia.</p><p>For most users, installation involves going to the website <a href="https://julialang.org/downloads/">https://julialang.org/downloads/</a> <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> and following the instructions. The website provides both binaries for your operating system as well as a command to install a package called <code>juliaup</code> which will allow you to easily update Julia in the future. Linux users (or those with the appropriate software on Windows or Mac) can also install Julia with their package manager. With Julia installed, the next step is decide how to edit code. There are generally two options here:</p><ol><li>With text editors. This means that you will use your text editor of choice (for example: vim, nano, notepad++) and then manage all of your code on your own. You might want to google around for most common options with Julia.</li><li>With development environments. These are collections of all the things programmers typically need for development packaged into one graphical interface. The most common one for Julia is VSCode, with full installation instructions found here: <a href="https://code.visualstudio.com/docs/languages/julia">https://code.visualstudio.com/docs/languages/julia</a><sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>.</li></ol><p>Keep in mind that if you are <em>not</em> using Julia and have instead decided to rewrite the code in this book in another language, the installation might be significantly different and potentially more complicated.</p><h2 id="Figuring-out-your-hardware"><a class="docs-heading-anchor" href="#Figuring-out-your-hardware">Figuring out your hardware</a><a id="Figuring-out-your-hardware-1"></a><a class="docs-heading-anchor-permalink" href="#Figuring-out-your-hardware" title="Permalink"></a></h2><p>Now that we have Julia installed, we can start using our GPU! As I discussed in the introduction, the current state of GPU programming is (unfortunately) quite fragmented, so the first step is to identify the hardware on your system. Ideally, you already know this information (because you bought or built your own computer and can look at the specifications), but here&#39;s some hints to figure out what you have depending on your operating system:</p><ul><li><strong>Windows</strong>: Go to the &quot;Device Manager&quot; and look under &quot;Display Adapters&quot;, where you should find the manufacturer of your GPU.</li><li><strong>Mac</strong>: Go to &quot;About this Mac&quot;. If it says you are running an &quot;Apple M<span>$x$</span>&quot; chip, where <span>$x$</span> is some number, then you can use your Apple Silicon GPU. Otherwise, there might some other GPU shown there.</li><li><strong>Linux</strong>: To be honest, there are a bunch of different ways to figure out what hardware you are running, so feel free to google and use your preferred method. My go-to is always <code>lspci | grep &quot;VGA&quot;</code>, which will tell you what GPUs you have. Other options include <code>lshw -C display</code> or just pasting <code>about:support</code> into the URL for Firefox.</li></ul><p>In the case you have more than one GPU available, feel free to use whichever one you want (or all of them). If you do not have a usable GPU, that is totally ok! You can use your CPU instead for almost everything in this book.</p><p>If you could not figure out whether you have a usable GPU at this stage, that&#39;s also totally fine. We can use Julia to figure out which packages will work on your machine. More on that in a moment.</p><p>For now, let&#39;s talk about the Julia packages available for your hardware:</p><table><tr><th style="text-align: right">Hardware Available</th><th style="text-align: right">Julia Package</th><th style="text-align: right">Julia Array Type</th></tr><tr><td style="text-align: right">Parallel CPU</td><td style="text-align: right">none</td><td style="text-align: right">Array</td></tr><tr><td style="text-align: right">NVIDIA GPU</td><td style="text-align: right">CUDA</td><td style="text-align: right">CuArray</td></tr><tr><td style="text-align: right">AMD GPU</td><td style="text-align: right">AMDGPU</td><td style="text-align: right">ROCArray</td></tr><tr><td style="text-align: right">Intel GPU</td><td style="text-align: right">oneAPI</td><td style="text-align: right">oneArray</td></tr><tr><td style="text-align: right">Apple Silicon</td><td style="text-align: right">Metal</td><td style="text-align: right">MtlArray</td></tr></table><p>Keep in mind that the package names here follow the naming conventions for the traditional software tooling of your hardware. Julia&#39;s package for NVIDIA GPUs is <code>CUDA</code>, because it compiles down to the same thing as CUDA (a C language extension for NVIDIA GPU tooling), but does so in Julia. At this point, if you already know your GPU hardware, simply install the relevant package by using the following commands:</p><ol><li><code>julia</code>: This will open the Julia shell (called the REPL, which stands for &quot;Read, Evaluate, Print, and Loop&quot;). You should see an ASCII Julia logo appear and then a green <code>julia&gt;</code> prompt.</li><li>Press the <code>]</code> key: This will open up the package manager and change the prompt to something like <code>(@v1.10) pkg&gt;</code>. It will also change the color of the prompt to blue.</li><li><code>add GPUBackend</code>: Where <code>GPUBackend</code> is the appropriate package listed in the table above. For example, I have an AMD GPU, so I will <code>add AMDGPU</code>. If I were running an M2 mac, I would <code>add Metal</code>. If I had an NVIDIA GPU, I would <code>add CUDA</code>. Keep in mind that this might take some time because it&#39;s installing a lot of GPU driver magic in the background.</li><li>Press backspace: This will leave the package manager</li><li>type <code>using GPUBackend</code>: Remember that <code>GPUBackend</code> is the package you need for your specific hardware. This will load the package in the Julia REPL. This might take a second as it&#39;s compiling everything for the first time.</li><li><code>GPUBackend.functional()</code>: This will test to make sure the package will work on your machine. It <em>should</em> return <code>true</code> if you have the right hardware available.</li></ol><p>If <code>GPUBackend.functional()</code> returns <code>false</code>, then there is something wrong with the configuration. That is absolutely no problem for the purposes of this text, as you can simply use parallel CPU execution instead of the GPU; however, it might be worth googling around to try to figure out why your GPU is not working (and maybe even create an issue on github for the appropriate package if you feel your GPU <em>should</em> be supported, but isn&#39;t).</p><p>Also note that there could have been any number of things that could have gone wrong during this installation process. If the steps above did not work for you, then it is important to search around for a solution. If you can&#39;t find a solution, then it&#39;s a good idea to reach out to the Julia slack community (there is a <code>#gpu</code> for this kind of thing) or the Julia Discourse. If neither of those resources are helpful, then it might be worth creating an issue for your specific GPU backend.</p><div class="admonition is-success"><header class="admonition-header">But what if I don&#39;t know my hardware?</header><div class="admonition-body"><p>In this case, just install all the packages and test them all. Remember, use <code>]</code> to enter the package manager (<code>(@v1.10) pkg&gt;</code>) and backspace to return to the Julia REPL (<code>julia&gt;</code>):</p><pre><code class="nohighlight hljs">(@v1.10) pkg&gt; add AMDGPU CUDA oneAPI Metal
julia&gt; using AMDGPU, Metal, oneAPI, CUDA
julia&gt; AMDGPU.functional()
true

julia&gt; Metal.functional()
false

julia&gt; oneAPI.functional()
false

julia&gt; CUDA.functional()
false</code></pre><p>Here, I have a working AMD GPU, but none of the other vendors will work. I omitted a few error messages that appeared on my machine when <code>using Metal</code> and <code>using oneAPI</code> as not all users will experience those errors. Both of these packages informed me immediately that my hardware was not supported, so I did not need to run <code>.functional()</code> on those packages (but I did anyway for clarity).</p><p>After you have found the appropriate package on your machine, feel free to remove the unnecessary ones with:</p><pre><code class="nohighlight hljs">(@v1.10) pkg&gt; rm GPUBackend1 GPUBackend2 GPUBackend3 ...</code></pre></div></div><div class="admonition is-success"><header class="admonition-header">But what if I can&#39;t (or don&#39;t want to) use the package mode (`]`)?</header><div class="admonition-body"><p>You can actually use the package manager as a package, itself, so...</p><pre><code class="nohighlight hljs">julia&gt; using Pkg
julia&gt; Pkg.add(&quot;GPUBackend&quot;)</code></pre><p>Where <code>GPUBackend</code> comes from the table above. There are a few situations where it just makes more sense to use the <code>Pkg</code> package instead of entering package mode with <code>]</code>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Reviewer Notice</header><div class="admonition-body"><p>I actually think the <code>using Pkg</code> method is more straightforward for beginners. Should we do that one by default and have a separate tip to explain the <code>]</code> package management mode?</p><p>I introduced <code>]</code> first because (let&#39;s be honest) that&#39;s how the majority of people interface with the package manager; however, <code>using Pkg</code> is necessary for scripts and CI, so it is also important to know.</p></div></div><p>As a final note before continuing, we will be using the notation from the previous table throughout this book. That is to say that I will be using <code>GPUBackend</code> to refer to your specific package (such as <code>AMDGPU</code> on my machine) and <code>ArrayType</code> to refer to the array type from that package (<code>ROCArray</code> on my machine). In the case you &quot;just want to run the code&quot; provided here, it might be worth setting these in your Julia REPL and future scripts. For example, on my machine, I might set:</p><pre><code class="nohighlight hljs">GPUBackend = AMDGPU
ArrayType = ROCArray</code></pre><p>If you are using your CPU to emulate GPU execution for this work, then you do not need to set your <code>GPUBackend</code> and instead can remove <code>GPUBackend</code> from all code blocks for them to run. It is up to you how you wish to proceed here and what suits your learning style best. Regardless, we should have all (hopefully) finished installation at this point, so it&#39;s time to actually get some work done.</p><h2 id="Your-first-GPU-array"><a class="docs-heading-anchor" href="#Your-first-GPU-array">Your first GPU array</a><a id="Your-first-GPU-array-1"></a><a class="docs-heading-anchor-permalink" href="#Your-first-GPU-array" title="Permalink"></a></h2><p>Alright, we&#39;ve chosen our appropriate package. Now let&#39;s create an array and pass the data to the GPU.</p><pre><code class="nohighlight hljs">julia&gt; a = zeros(10, 10)
julia&gt; b = ArrayType(a)</code></pre><p>There are a lot of things to talk about. <code>zeros(...)</code> is a Julia method to create an array that is all 0 of a particular size. Here, it&#39;s 10 by 10. This command will create an <code>Array</code> object whose memory exists &quot;on the CPU&quot;. More accurately, the memory will sit on the motherboard RAM, a convenient location for CPU operations. We then need to send that data to the GPU by casting it onto the appropriate array type for our hardware with <code>ArrayType(a)</code>. Here, <code>ArrayType</code> is the array type from the table above. For example, those with an AMD GPU would use <code>ROCArray</code>. Those with an NVIDIA GPU would use <code>CuArray</code>. Those with Apple Silicon would use <code>MtlArray</code>.</p><p>It is important to note that the command <code>ArrayType(a)</code> is actually doing two things at once:</p><ol><li>Allocating the appropriate space on the GPU</li><li>Copying the data from the CPU to GPU.</li></ol><p>In Julia, these two steps are often coupled, but they don&#39;t need to be. For instance, In CUDA (C) a user might use both a <code>cudaMalloc(...)</code> and <code>cudaMemcpy(...)</code>. In Julia, we could also avoid the memory transfer and create the array directly on the GPU with:</p><pre><code class="nohighlight hljs">b = GPUBackend.zeros(10,10)</code></pre><p>This would avoid the (relatively) costly communication between the CPU and GPU. In fact, most of the array creation routines (such as <code>rand(...)</code>, and <code>ones(...)</code> have similar routines for each backend for simplicity.</p><div class="admonition is-success"><header class="admonition-header">A note about Macs</header><div class="admonition-body"><p>If you are running a Mac, you might not have been able to create your array on the GPU. This is because Metal (the interface used for GPU computation on Apple Silicon) only supports single precision (<code>Float32</code> and <code>Int32</code> for example). So to create the necessary array on a mac, specify the type for <code>zeros(...)</code> first, like so:</p><pre><code class="nohighlight hljs">julia&gt; a = zeros(Float32, 10, 10)
julia&gt; b = MtlArray(a)
</code></pre></div></div><p>Now, depending on your machine, you might have had to wait a few seconds to generate your initial array. What gives? Isn&#39;t GPU computing supposed to be fast? Why do we need to wait around all the time?</p><p>Well, one core difference between CPU and GPU programming is in how users think about the code. On the CPU, users typically think about the number of operations each core is performing. Though this is still important with the GPU, calculation speed is often not the biggest bottleneck to GPU performance. Instead, GPU programmers need to think about data flow, where data is in GPU memory. As a rule of thumb, the slowest part of any computation is communication – specifically communication between the CPU and GPU, but also between different memory banks within the GPU, itself. This has a large number of implications that we will discuss in later chapters.</p><p>Even so, the transfer time of data for a relatively small array (like this one) <em>should</em> still be around a millisecond or two. My guess is that most users felt a significant delay of about a second or two when they created their first array. As a quick test, try to do the same command again (<code>ArrayType(a)</code>). This time, it should be really fast. The truth is that there is another, more important reason why the first array took so long to build. Let&#39;s talk about...</p><h3 id="Expected-performance-from-Julia"><a class="docs-heading-anchor" href="#Expected-performance-from-Julia">Expected performance from Julia</a><a id="Expected-performance-from-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#Expected-performance-from-Julia" title="Permalink"></a></h3><p>It&#39;s time to be upfront about one of the core weaknesses of Julia. At this stage, there are probably two distinct groups of people:</p><ol><li>Those that are new to GPU programming. These people are probably scratching their head at all the new, unnecessary packages. After all, they just want to use their GPU! Why do they need to think so deeply about their hardware?</li><li>Those who have attempted GPU programming before. These people are probably amazed at how easy the installation was. Julia <em>just did everything for us</em> in a way that seemed like magic!</li></ol><p>There is a little truth to both of these claims. Yes, Julia does a lot of the heavy lifting for the user. And yes, there is still a lot of jank we are trying to get rid of.</p><p>But there&#39;s another (potentially ill-formed) thought that might be lurking in the back of your mind, &quot;If all these Julia packages are just wrappers to C, why not use C instead? Won&#39;t we get a performance penalty for using Julia here?&quot;</p><p>That&#39;s a very good question, and it&#39;s difficult to fully explain. Long story short, Julia boils down to the same lower-level representation as C (if you are using the clang compiler), so it should be equivalently fast. It can also call C code without any performance penalty, so the wrappers to C should be equivalently fast. That said, we do need to draw a thin line in the sand here. In the case of GPU computing, we are not comparing ourselves to C, but CUDA (or Metal, AMD, etc). The lower-level representation of GPU languages are all <em>slightly</em> different than that of C. This means that in the case of GPU computing, we are actually asking Julia to do a lot. It has to dynamically determine our hardware, compile the Julia code into some intermediate representation, then spit out even lower level code that is distinct for each hardware vendor, all while maintaining the features that make Julia easy to use for beginners.</p><p>When we put it all together, the compilation time for the JuliaGPU ecosystem can sometimes be much higher than for many other GPU languages. To be clear, we usually call compilation &quot;<strong>pre</strong>compilation&quot; in Julia because the translation happens dynamically (immediately after Julia can statically know what all the types are when the user runs their code). Let&#39;s try to quantify our precompilation cost a bit by re-running the code with the <code>@time</code> macro:</p><pre><code class="nohighlight hljs">julia&gt; a = zeros(10,10);

julia&gt; GPUBackend.@time ROCArray(a);

julia&gt; GPUBackend.@time ROCArray(a)</code></pre><p>For me, this looks like:</p><pre><code class="nohighlight hljs">julia&gt; a = zeros(10,10);

julia&gt; AMDGPU.@time ROCArray(a);
  1.676601 seconds (7.35 M allocations: 508.234 MiB, 14.36% gc time, 85.91% comp
ilation time)

julia&gt; AMDGPU.@time ROCArray(a);
  0.000370 seconds (12 allocations: 368 bytes)</code></pre><p>The second run was literally 4,500 times faster! It&#39;s important to also look at the information in parentheses. The first run had 7.35 million allocations and spent 85% of it&#39;s time precompiling. The other roughly 15% of time was spent on garbage collection (cleaning up unnecessarily allocated memory). The second run had 12 allocations and no time at all on garbage collection or precompilation. It was also less than a millisecond.</p><p>It is really important to keep in mind that Julia can (and should) get comparable performance to C in most cases, but we need to give it a second to precompile everything first. Even though many people in the Julia community are working on decreasing precompilation time, it is unlikely that this will go away entirely any time soon. If your specific GPU project requires fast recompilation regularly (which is the case for some graphics workflows), then you might need to take the lessons from this book and translate them into another language in the future.</p><p>That said, I truly believe that Julia provides the most flexible ecosystem for most GPU workflows and should be a great starting language for any GPU project. In particular, it is the only language that provides so many different abstractions for doing GPU computation. Speaking of which, it&#39;s time to talk about them in detail.</p><h2 id="I-have-a-GPU-array.-Now-what?"><a class="docs-heading-anchor" href="#I-have-a-GPU-array.-Now-what?">I have a GPU array. Now what?</a><a id="I-have-a-GPU-array.-Now-what?-1"></a><a class="docs-heading-anchor-permalink" href="#I-have-a-GPU-array.-Now-what?" title="Permalink"></a></h2><p>Well, there are a lot of things we can do, actually, but let&#39;s start with the basics: indexing. Indexing is the act of accessing array memory one element (index) at a time. On the CPU, you might create an array, <code>a</code>, and get the first index with <code>a[1]</code>. It might be reasonable to assume that similar logic would work on the GPU, so let&#39;s try it:</p><pre><code class="nohighlight hljs">julia&gt; using GPUBackend

julia&gt; a = ones(10,10);

julia&gt; b = ArrayType(a);

julia&gt; a[1]
1.0

julia&gt; b[1];
ERROR: Scalar indexing is disallowed.
Invocation of getindex resulted in scalar indexing of a GPU array.
This is typically caused by calling an iterating implementation of a method.
Such implementations *do not* execute on the GPU, but very slowly on the CPU,
and therefore should be avoided.

If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`
to enable scalar iteration globally or for the operations in question.
Stacktrace:

...
</code></pre><p>As a reminder, <code>GPUBackend</code> and <code>ArrayType</code> depends on your hardware and can be found in the installation section.</p><p>But what&#39;s the deal? Why can&#39;t I access elements of my GPU array? What does &quot;scalar indexing&quot; even mean?</p><p>Simply put, scalar indexing is the act of accessing an array one element at a time, for example <code>a[1]</code>, <code>a[2]</code>, or <code>a[i]</code>, where <code>i</code> is some integer value. As to why this is not allowed on the GPU, well... there are a bunch of factors all working against each other to make scalar indexing difficult. Remember, GPU memory is not &quot;on the CPU.&quot; When we run <code>a[1]</code>, we are asking Julia to display that data in the REPL, but we can&#39;t do that without first transferring it to the motherboard RAM. With this scalar indexing error, Julia is asking us to be doubly sure that this is, in fact, what we want to do because (again) communication is slow. If we are absolutely sure that we want to display the first element of <code>b</code>, then it is best to be more explicit and first transfer the data back to the CPU with something like <code>Array(b)[1]</code>, where <code>Array(b)</code> will transfer the data, and the <code>[1]</code> at the end will access the first element of the newly created CPU-based array.</p><p>It&#39;s also important to remember that GPUs are intended to do a lot of things in parallel. This power is lost completely if we ask Julia to deal with only a single element at a time. Simply put, if users are using the GPU one index at a time, it&#39;s going to be really, really slow, so we need to do what we can to discourage that behaviour whenever possible.</p><div class="admonition is-success"><header class="admonition-header">But what if I *really* need scalar indexing</header><div class="admonition-body"><p>Keep in mind that if you <em>really</em> need to access a single element of a GPU array and do not want to transfer the data to the CPU first, you can do it by first setting the <code>allowscalar</code> flag <code>true</code> (and then turning it off again afterwards):</p><pre><code class="nohighlight hljs">julia&gt; GPUBackend.allowscalar(true)
┌ Warning: It&#39;s not recommended to use allowscalar([true]) to allow scalar indexing.
│ Instead, use `allowscalar() do end` or `@allowscalar` to denote exactly which operations can use scalar operations.
└ @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:188

julia&gt; b[1]
1.0

julia&gt; GPUBackend.allowscalar(false)
</code></pre><p>You can also wrap the necessary code in a <code>do</code> block, like so:</p><pre><code class="nohighlight hljs">GPUBackend.allowscalar() do
    b[1]
end
</code></pre><p>Or use the provided macro</p><pre><code class="nohighlight hljs">GPUBackend.@allowscalar b[1]</code></pre></div></div><p>So now that we&#39;ve shaken everyone up a little bit by talking about something that is simultaneously trivial on CPUs and next to impossible on GPUs, let&#39;s talk about things we can <em>actually</em> do with our GPU array.</p><p>In the next few sections, I will be discussing three different abstractions that are commonly used for GPU programming:</p><ol><li>Broadcasting: the act of applying the same command to every element in an array.</li><li>GPU functions (called kernels): the act of writing a specific function that gives instructions to each GPU core</li><li>Loop vectorization: the act of transforming a <code>for</code> or <code>while</code> loop for GPU execution.</li></ol><p>Before going further, it&#39;s worth noting that these abstractions are not available for all languages. For example, CUDA and OpenCL focus almost exclusively on user-defined GPU functions. SyCL and Kokkos focus on loop vectorization. Julia is unique in that all three of these major abstractions are deeply ingrained into the ecosystem as a whole and play very nicely not only with each other, but the broader Julia ecosystem.</p><p>If you are planning on rewriting all the code in this book with another language, it might be a good idea to first jump to the abstraction that works well in the language you have chosen and then come back to the other sections as needed. For now, I intend to cover things in the order that feels most intuitive for GPU computation in Julia, starting with...</p><h3 id="Broadcasting"><a class="docs-heading-anchor" href="#Broadcasting">Broadcasting</a><a id="Broadcasting-1"></a><a class="docs-heading-anchor-permalink" href="#Broadcasting" title="Permalink"></a></h3><p>Ok. I get it. Most programmers have probably never used broadcasting. Many have probably never heard of it before now. Before using Julia, I certainly hadn&#39;t. So let&#39;s start at the start.</p><p>To reiterate, <em>broadcasting</em> is the act of applying the same command (broadcasting in the colloquial sense) to every element in an array. Though accessing individual elements of a GPU array is a little complicated, applying the same operation to all elements of an array is surprisingly easy – in fact, it&#39;s perfect for the GPU!</p><p>So let&#39;s look at some basic syntax on the CPU first:</p><pre><code class="nohighlight hljs">julia&gt; a = zeros(10)
10-element Vector{Float64}:
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0

julia&gt; a .= 1
10-element Vector{Float64}:
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
</code></pre><p>In Julia, the <code>.</code> before some command indicates to the compiler that the user would like to broadcast the command to all elements of an array. So, these lines:</p><ol><li>Created an array (<code>Vector</code>) of ten zeros, called <code>a</code>.</li><li>Broadcasted the <code>= 1</code> command to each element of the array, indicated with <code>.= 1</code></li></ol><p>Now for some Julia magic: as long as you are can write your GPU code as broadcasted operations, it should be possible to execute that code in parallel on the GPU. For example, the following will also work:</p><pre><code class="nohighlight hljs">julia&gt; using GPUBackend

julia&gt; a = GPUBackend.zeros(10);

julia&gt; a .+= 1
10-element ArrayType{Float32, 1, ...}:
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
</code></pre><p>And there you have it! You&#39;ve just executed your first function on the GPU. Note that in this case, we switched things up a bit and used the <code>.+=</code> command instead of <code>.=</code>. This simply means that we added 1 to every element (the <code>+=</code> operation) instead of setting every element equal to (<code>=</code>) 1. That said, we probably want to do things way more complicated than just adding one to every element of an array, so let&#39;s look at a few quick examples of broadcasting in practice.</p><div class="admonition is-success"><header class="admonition-header">What&#39;s up with the semicolon (`;`)?</header><div class="admonition-body"><p>In the Julia REPL, you can add a semicolon (<code>;</code>) to the end of a line if you do not want to show the output immediately. I&#39;ll be using this throughout the book to make the text a little more clear to read.</p></div></div><h4 id="Setting-every-odd-element-to-1"><a class="docs-heading-anchor" href="#Setting-every-odd-element-to-1">Setting every odd element to 1</a><a id="Setting-every-odd-element-to-1-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-every-odd-element-to-1" title="Permalink"></a></h4><p>We just added one to every element. What if we want to do something similar, but for every <em>odd</em> element? To do this, we need to define a custom <em>range</em> for accessing our Julia array. For example, if we want access only the first five elements of an array, we might use the range <code>1:5</code>. If we want to choose every other element, then we would go in steps of two, so <code>1:2:5</code>. Putting this together, if we want to set every odd element of an array to 1, we might do...</p><pre><code class="nohighlight hljs">julia&gt; a = zeros(10);

julia&gt; a[1:2:10] .= 1;

julia&gt; a
10-element Vector{Float64}:
 1.0
 0.0
 1.0
 0.0
 1.0
 0.0
 1.0
 0.0
 1.0
 0.0
</code></pre><p>And that&#39;s that. This was just a simple way of showing that any mathematical operation can be broadcasted, even if that operation is just assigning values.</p><p>Now for a few quick exercises to make sure we understand everything:</p><div class="admonition is-todo"><header class="admonition-header">Problem 1: Do it on the GPU</header><div class="admonition-body"><p>Do what we just did on your GPU backend. In other words, change the array type of <code>a</code> to your <code>ArrayType</code> and add one to every other element.</p></div></div><div class="admonition is-todo"><header class="admonition-header">Problem 2: Subtract 1 from every even element</header><div class="admonition-body"><p>Create some broadcast operation that will subtract one from every even element.</p></div></div><div class="admonition is-todo"><header class="admonition-header">Problem 3: Square each element of the array</header><div class="admonition-body"><p>For context, <code>x^y</code> is the math operator in Julia to &quot;raise some number (<code>x</code>) to the power of some other number (<code>y</code>). So the squaring operator in Julia for a single value would look like <code>x ^= 2</code>.</p><p>Now broadcast that operation to your entire array.</p></div></div><h4 id="What&#39;s-the-difference-between-indexing-and-broadcasting?"><a class="docs-heading-anchor" href="#What&#39;s-the-difference-between-indexing-and-broadcasting?">What&#39;s the difference between indexing and broadcasting?</a><a id="What&#39;s-the-difference-between-indexing-and-broadcasting?-1"></a><a class="docs-heading-anchor-permalink" href="#What&#39;s-the-difference-between-indexing-and-broadcasting?" title="Permalink"></a></h4><p>Right. Good question.</p><p>We just had two sections back-to-back with seemingly contradictory claims:</p><ol><li>It&#39;s not a good idea to grab individual indices of a GPU array.</li><li>It&#39;s a <em>great</em> idea to grab multiple indices at once.</li></ol><p>For many users, it might not be clear what the distinction is here. After all, what is the difference between <code>a[1]</code> and <code>a[1:5]</code>? Why is the latter so fundamentally different in Julia?</p><p>It is actually difficult to answer this question without digging in to the Julia programming language, itself (and the <code>base/broadcast.jl</code> file), but the simplest explanation is that the <code>.</code> before any operation signifies that the user would like to call the Julia <code>map</code> function, which distributes a function across elements of an array. For the Julia GPU ecosystem (in the <code>GPUArrays.jl</code> package), any broadcasted operation will actually create a specific GPU function for the <code>map</code>.</p><p>Simply put: if you are just trying to access a single element of a GPU array, we can not easily transform that into a GPU function that works in parallel on your hardware. If you are trying to <em>do something</em> with a bunch of elements, then it is easy(ish) to do so.</p><p>And if you are wondering, yes. This does mean that you can get around the scalar indexing warning by using a range with only a single element, like:</p><pre><code class="nohighlight hljs">julia&gt; a = zeros(5):

julia&gt; b = ROCArray(a):

julia&gt; b[1:1]
1-element ROCArray{Float64, 1, AMDGPU.Runtime.Mem.HIPBuffer}:
 0.0</code></pre><p>Please don&#39;t abuse this too much.</p><h4 id="Vector-addition"><a class="docs-heading-anchor" href="#Vector-addition">Vector addition</a><a id="Vector-addition-1"></a><a class="docs-heading-anchor-permalink" href="#Vector-addition" title="Permalink"></a></h4><p>When it comes to GPU computation, there is a single problem that every single person does to make sure their code is working as intended. It is so common, that the problem is often called the &quot;&#39;Hello World!&#39; of GPU computation. That problem is vector addition, the act of adding two vectors (lists of numbers) together. Let&#39;s do it with broadcasting.</p><pre><code class="nohighlight hljs">julia&gt; a = rand(10)
10-element Vector{Float64}:
 0.3446361752270596
 0.6044872863666282
 0.8081681226442919
 0.6586667828785924
 0.23172116207667204
 0.08632001843030668
 0.09675977506693823
 0.6771842850312151
 0.019671351328815923
 0.7149572102336769

julia&gt; b = rand(10)
10-element Vector{Float64}:
 0.30677966842793747
 0.27954729235962206
 0.37278805220786826
 0.7667780614002805
 0.9295691111986113
 0.6457830807742259
 0.4943043624323966
 0.8731592407550742
 0.3415622970290325
 0.32403477239711587

julia&gt; c = a .+ b
10-element Vector{Float64}:
 0.651415843654997
 0.8840345787262502
 1.1809561748521602
 1.4254448442788727
 1.1612902732752834
 0.7321030992045325
 0.5910641374993348
 1.5503435257862894
 0.36123364835784844
 1.0389919826307927</code></pre><p>So there&#39;s a lot to unpack here. Firstly, broadcasting can work in general on the right-hand side of any math equation (here shown with the <code>.+</code> between <code>a</code> and <code>b</code>).. Secondly, <code>rand(...)</code> works the same way as <code>zeros(...)</code> or <code>ones(...)</code>. Right now that might seem trivial, but random numbers are actually a little hard to do on GPUs, so we&#39;ll talk about that in a little more depth later. Thirdly, it&#39;s important to note that <code>a</code> and <code>b</code> must be the same size for this to work, so make sure that&#39;s true before broadcasting operations to more than one array.</p><p>But there&#39;s a more subtle point here that many people might have missed, and it has to do with the third command, <code>c = a .+ b</code>. Simply put, <code>c</code> did not exist before running the command! This means that we have created a new array for the sole purpose of outputting the results of  <code>a .+ b</code>.</p><p>Though this might not seem particularly noteworthy on the CPU, it actually has large implications for the GPU. Remember that the slowest part of most computation is memory management, and here, we have allocated space for and assigned the values to a random array without even considering the consequences to performance! Allocation takes time! If at all possible, we want to minimize the number of times we create new arrays.</p><p>So how might we rewrite things so that we don&#39;t unnecessarily allocate <code>c</code>? Well, the simplest solution is to allocate it at the same time as <code>a</code> and <code>b</code> and then use <code>.=</code> instead of <code>=</code>:</p><pre><code class="nohighlight hljs">julia&gt; a = rand(10);

julia&gt; b = rand(10);

julia&gt; c = similar(a);

julia&gt; c .= a .+ b</code></pre><p>Here, we use <code>similar(a)</code>, which will create an array that is the same size, shape, and type as <code>a</code>, which should (hopefully) also be the same size, shape, and type as <code>b</code>. The data in <code>c</code> from <code>similar</code> will be just whatever junk was in memory at the time and won&#39;t necessarily be all zeros or anything. That shouldn&#39;t matter because <code>c</code> is used exclusively for output, so there&#39;s no reason to invoke <code>rand(...)</code> if we don&#39;t need it.</p><p>There are actually distinct terms to distinguish between the two different types of computation we did:</p><ol><li><strong>In Place</strong> computation is when all operations act on <em>already existing</em> data. In this case, the <code>.=</code> command broadcasts <code>c[i] = a[i] + b[i]</code> to all elements of the array, assuming <code>a</code>, <code>b</code>, and <code>c</code> already exist.</li><li><strong>Out of Place</strong> computation is when some operations <em>create new data</em>. In this case, the <code>=</code> sign assigns the output of <code>a .+ b</code> to a new array, called <code>c</code>.</li></ol><p>So <code>c = a .+ b</code> was <em>out of place</em>, while <code>c .= a .+ b</code> was <em>in place</em>. It&#39;s important to keep this in mind for later. Remember that data flow <em>really</em> matters with GPU computation, so it&#39;s doubly important to make sure you know where your data lives.</p><p>A quick note. I would like to believe that <em>every single Julia programmer</em> has been tripped up by the difference between <code>=</code> and <code>.=</code>. I certainly have torn my own hair out late in the evening, trying to figure out why the performance of my code is so slow, only to realize I forgot a single <code>.</code>, which meant that I was creating a bunch of new arrays instead of writing to pre-existing arrays. This type of stuff happens to the best of us, which is why I am pointing it out now while you are young and impressionable. Julia syntax sometimes looks sleek, but there&#39;s a lot of power under-the-hood, so it is wise to take a second and make sure every line is actually doing what you want. </p><p>I think that&#39;s it for now. On to some problems.</p><div class="admonition is-todo"><header class="admonition-header">Problem 4: Try to add arrays of different sizes</header><div class="admonition-body"><p>... and see the error message.</p></div></div><div class="admonition is-todo"><header class="admonition-header">Problem 5: Do it on the GPU</header><div class="admonition-body"><p>Create three arrays, <code>a</code>, <code>b</code>, and <code>c</code>, all of type <code>ArrayType</code> for your specific GPU backend. Add <code>a</code> and <code>b</code> together and output them to <code>c</code>. You may create <code>a</code>, <code>b</code>, and <code>c</code> in any way you wish, but it might be more interesting to use <code>ones(...)</code> or <code>rand(...)</code> instead of <code>zeros(...)</code> because <span>$0 + 0 = 0$</span>.</p></div></div><div class="admonition is-todo"><header class="admonition-header">Problem 6: Add the first five elements of `a` to the last five elements of `b`</header><div class="admonition-body"><p>Create custom ranges so you can add one through five of <code>a</code> to five through ten of <code>b</code>. Remember that your output array (<code>c</code>), should be five elements this time!</p></div></div><h4 id="Broadcasting-generic-functions"><a class="docs-heading-anchor" href="#Broadcasting-generic-functions">Broadcasting generic functions</a><a id="Broadcasting-generic-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Broadcasting-generic-functions" title="Permalink"></a></h4><p>Until now, we have been broadcasting pre-defined Julia functions (mainly math operations), but what if we wanted to broadcast our own (user-defined) functions? Well, let&#39;s do that. Let&#39;s say we wanted to find ten numbers between one and one-hundred. We might create a function that looks like this:</p><pre><code class="nohighlight hljs">julia&gt; f(x) = round(Int, x*100)</code></pre><p>This would take some input (<code>x</code>), multiply it by one-hundred, and then round it to the nearest integer value (<code>Int</code>). So <code>f(0.5)</code> is <code>50</code>. <code>f(0.6542)</code> is <code>65</code>. And so on. Now let&#39;s broadcast that function to an array of random numbers:</p><pre><code class="nohighlight hljs">julia&gt; a = rand(10);

julia&gt; f.(a)
10-element Vector{Int64}:
 15
 46
 12
 11
 15
 13
 13
 60
 89
 89
</code></pre><p>Here, we&#39;ve used the <code>.</code> operator to signify that we want the function broadcasted along all elements of the argument of <code>f</code>. Now let&#39;s create another function to do the vector addition from the previous section:</p><pre><code class="nohighlight hljs">julia&gt; g(a, b) = a + b
g (generic function with 1 method)

julia&gt; a = rand(10);

julia&gt; b = rand(10);

julia&gt; c = similar(a);

julia&gt; c .= g.(a, b)
10-element Vector{Float64}:
 1.1339661653178916
 0.9405969685936231
 1.576334145965099
 0.6608638707221182
 1.2142578652057847
 1.3606689325191113
 0.7669673576476489
 1.7838687185111035
 1.370863980086035
 1.5491853434156098
</code></pre><p>There are actually many different ways we could have done that. For example, we could have made <code>g</code> use <code>c</code> as an argument and then used <code>g.(c, a, b)</code>. We could have also written our function using slightly different syntax in Julia, like:</p><pre><code class="nohighlight hljs">functon g(a, b)
    return a + b
end</code></pre><p>Feel free to explore different ways to do this if you want. In fact, I actively encourage you to do so.</p><p>For now, let&#39;s wrap everything we&#39;ve learned about broadcasting into a worked example that also shows off some of the power of GPU computing.</p><div class="admonition is-info"><header class="admonition-header">Reviewer Notice</header><div class="admonition-body"><p>I am thinking of replacing this upcoming section with something else that is potentially more interesting. Maybe one of the <a href="https://en.wikipedia.org/wiki/Diehard_tests">Diehard tests</a>? I just couldn&#39;t think of one that works so well with broadcasting.</p></div></div><h4 id="A-simple-exercise:-&quot;Where-did-the-noise-go?&quot;"><a class="docs-heading-anchor" href="#A-simple-exercise:-&quot;Where-did-the-noise-go?&quot;">A simple exercise: &quot;Where did the noise go?&quot;</a><a id="A-simple-exercise:-&quot;Where-did-the-noise-go?&quot;-1"></a><a class="docs-heading-anchor-permalink" href="#A-simple-exercise:-&quot;Where-did-the-noise-go?&quot;" title="Permalink"></a></h4><p>Until now, I have avoided timing the majority of the our code because I wanted to make a point about GPU computation. Namely, if you are only working with a few elements at a time, the CPU will usually be faster. For example, here are the timing results for vector addition on my computer. First, let&#39;s do the CPU:</p><pre><code class="nohighlight hljs">julia&gt; a = rand(10);

julia&gt; b = rand(10);

julia&gt; c = similar(a);

julia&gt; @time c .= a .+ b
  0.000003 seconds (1 allocation: 32 bytes)
</code></pre><p>Now for the GPU:</p><pre><code class="nohighlight hljs">julia&gt; using AMDGPU

julia&gt; gpu_a = ROCArray(a);

julia&gt; gpu_b = ROCArray(b);

julia&gt; gpu_c = similar(gpu_a);

julia&gt; AMDGPU.@time gpu_c .= gpu_a + gpu_b;
  0.000054 seconds (46 allocations: 2.500 KiB)
</code></pre><p>Note that for both of these timings, I have shown only the results of the second run of the code to avoid precompilation overhead. Even so, it&#39;s clear the CPU is faster. How much faster?</p><pre><code class="nohighlight hljs">julia&gt; 0.000054 / 0.000003
18.0
</code></pre><p>18 times. It&#39;s 18 times faster to avoid the GPU entirely! Why? Well, we are doing operations that are a little <em>too</em> simple on arrays that are really, really small. I mean, the CPU took three <em>micro</em>seconds. The GPU was fifty-four microseconds. Can we really draw any conclusions from such small numbers?</p><p>To really see some performance from the GPU, let&#39;s do something a little complicated. We are going to make an array of random numbers... disappear!</p><p>First, let&#39;s install the plotting package, <code>Plots</code>. Remember to enter Julia&#39;s package mode with <code>]</code> (and then <code>enter</code>). Then:</p><pre><code class="nohighlight hljs">(@v1.10) pkg&gt; add Plots</code></pre><p>Now press backspace to enter the Julia shell. We can now create a large matrix of random numbers and plot it:</p><pre><code class="nohighlight hljs">julia&gt; using Plots

julia&gt; a = rand(1920, 1080);

julia&gt; heatmap(a; clims = (0,1))</code></pre><p>I have chosen to make the array 1920x1080 because that mirrors the resolution of a high-definition display. Also, we are using <code>heatmap</code> here (instead of <code>plot</code>) because we want a 2D image as output. I am also using color limits (<code>clims</code>) from zeros to one. This should create an image that looks like this:</p><p><img src="../abstractions_res/out_1.png" alt="Initial Random Array"/></p><p>Now we are simply going to create a function that adds a random number to elements of <code>a</code>, so:</p><pre><code class="nohighlight hljs">f(x) = x + rand()</code></pre><p>Finally, we&#39;ll execute the command 1000 times in a loop and average the results</p><pre><code class="nohighlight hljs">julia&gt; @time for i = 1:1000
           a .= f.(a)
       end
  1.270488 seconds (1000 allocations: 15.625 KiB)

julia&gt; a ./= 1000;</code></pre><p>It took about 1.5 seconds to do the computation and creates the following image (with <code>heatmap(a; clims = (0,1))</code>:</p><p><img src="../abstractions_res/out_2.png" alt="Initial Random Array"/></p><p>Wow! The color is gone from our plot as all the values have averaged to 0.5! What happened? Well, we just took 1000 random samples on each pixel and averaged them. Because <code>rand(...)</code> gives us a random number between 0 and 1, the final value for each pixel should be the average of 0 and 1, which is 0.5.</p><div class="admonition is-info"><header class="admonition-header">About looping in Julia...</header><div class="admonition-body"><p>Looping in Julia (and in many languages) generally has two modes: <code>for</code> and <code>while</code>. We have just seen the <code>for</code> loop in practice and is most often used over a range of a certain number of elements. For example:</p><pre><code class="nohighlight hljs">for i = 1:10
    println(i)
end</code></pre><p>Will set the value of <code>i</code> to be 1, execute the commant, then set the value of <code>i</code> to be 2 and execute the command again. After that, it will set the value of <code>i</code> to be 3 and execute the command again. It will continue this process until it reaches the end of the range provided (<code>1:10</code>), which is 10 in this case. This process is known as &quot;iteration&quot; and will be discussed in more detail later in this chapter when we talk about loop vectorization. For now, I&#39;ll mention that the <code>for</code> loops allows users to iterate through any container, including <code>Arrays</code>, but not GPUArrays due to the scalar iteration issue discussed earlier. So the following is also valid:</p><pre><code class="nohighlight hljs">julia&gt; a = [1,3,5,7];

julia&gt; for i in a
           println(i)
       end
1
3
5
7</code></pre><p>The other common looping structure in Julia is the <code>while</code> loop, which continues executing the same command over and over until some condition is evaluated as <code>false</code>. For example:</p><pre><code class="nohighlight hljs">i = 1
while i &lt;= 10
    println(i)
    i += 1
end</code></pre><p>This code will also print 1 through 10 as above becaue when <code>i</code> evaluates as 11, the statement <code>i &lt;= 10</code> is evaluated as <code>false</code>, breaking the loop. We&#39;ll be showing off a bunch of tricks you can do with looping in Julia throughout this text, but it is worthwhile to take a second to introduce them to users who might not be familiar with the syntax.</p></div></div><p>Ok. I get it. It&#39;s not that impressive. There are some fun discussions we could have about testing how random random number generators truly are, but that would take a lot of time. If you are interested in that kind of stuff, I would recommend you look into Diehard tests. They are a fun suite of tests specifically for random number generation. For now, we&#39;ll move on to the real magic and run the same code on the GPU:</p><pre><code class="nohighlight hljs">julia&gt; AMDGPU.@time for i = 1:1000
           b .= f.(b)
       end
  0.001738 seconds (18.00 k allocations: 1.068 MiB)

julia&gt; b ./= 1000;</code></pre><p>Did you see that? 1.738 <em>milli</em>seconds. That&#39;s roughly 1000 times faster than our CPU implementation!</p><p>Here we (finally) start to see a glimpse of the true power of GPU computing. On the one hand, we need to balance our complexity a bit. If the code is too complex, the CPU will do it better because each individual core is stronger. If there is not enough data (<code>zeros(10)</code>), again it&#39;s better to stick to the CPU. But when the GPU is in its element, it can really shine.</p><p>Now, don&#39;t expect every problem to be 1000 times faster on the GPU. I have specifically manufactured this toy problem to show off how fast it can be. In actual applications, developers typically see anywhere from 5-100 times improvement depending on the situation. Still, it&#39;s nice to know that we are doing all of this for a good reason: performance.</p><div class="admonition is-todo"><header class="admonition-header">Problem 7: Do it on your machine</header><div class="admonition-body"><p>I know some of you were tic-tac-typing along with me through the last exercise. Some were not. This problem is a gentle encouragement from me to you to make doubly sure you can do the previous example on your own machine with your own GPU.</p></div></div><div class="admonition is-todo"><header class="admonition-header">Problem 8: Make a sine wave</header><div class="admonition-body"><p>Create a range from 0 to 2pi (for example <code>0:0.1:2pi</code>). Send that to the GPU and broadcast a sine operation to each element (<code>sin.(...)</code>). After, plot the results (<code>plot(...)</code>).</p></div></div><div class="admonition is-info"><header class="admonition-header">Reviewer Notice</header><div class="admonition-body"><p>I need a few more good problems for this section. Or maybe not? I&#39;ll have a bunch more problems at the end and there&#39;s only so much you can do with broadcasting.</p></div></div><p>I think it&#39;s time to take a second to discuss the limitations of broadcasting.</p><h4 id="Some-room-for-development"><a class="docs-heading-anchor" href="#Some-room-for-development">Some room for development</a><a id="Some-room-for-development-1"></a><a class="docs-heading-anchor-permalink" href="#Some-room-for-development" title="Permalink"></a></h4><p>So here&#39;s a weird quirk of the Julia ecosystem. Something that might cause us to reconsider the speedup noted in the previous section. Even though broadcasted operations performed on a GPU array are done in parallel by default, the same is not true for traditional CPU <code>Array</code>s. To be doubly clear, this will be executed in parallel:</p><pre><code class="nohighlight hljs">a = GPUBackend.ones(100)
a .+= a</code></pre><p>but this will not:</p><pre><code class="nohighlight hljs">a = ones(100)
a .+= a</code></pre><p>There are a lot of good reasons for why this is the case. Some of it comes down to engineering time. Some of it comes down to active research questions regarding the proper procedure to distribute generic operations in parallel. For the purposes of this book, none of that matters because we are talking about GPU execution, specifically.</p><p>Ultimately, this means that the comparison between the CPU and GPU made in the previous section might not have been entirely fair. We were not comparing <em>parallel</em> CPU to parallel GPU. Instead, we were comparing a single CPU core to the <em>entire power</em> of the GPU. If I were instead to use all the cores available on my machine (16), then we could expect to see an order of magnitude improvement on the previous result for the CPU. So instead of a 1000 times improvement, there might have been only 50 or so.</p><p>All said, it&#39;s good to point out areas within the Julia language that are being worked on, but are not fully finished yet. In fact, there are a bunch of similar stories throughout the GPU ecosystem and I will try to point these out as they come up.</p><h4 id="Final-musings-on-broadcasting-for-GPU-computation"><a class="docs-heading-anchor" href="#Final-musings-on-broadcasting-for-GPU-computation">Final musings on broadcasting for GPU computation</a><a id="Final-musings-on-broadcasting-for-GPU-computation-1"></a><a class="docs-heading-anchor-permalink" href="#Final-musings-on-broadcasting-for-GPU-computation" title="Permalink"></a></h4><p>When started working at MIT, I was excited to see what people were actually using the GPU ecosystem in Julia for. At the time, I came across an ocean simulation project with incredibly enthusiastic developers. It was fast and intuitive to use, and they highlighted the fact that it was fully functional on the GPU. Coming from a more traditional graphics background, I was shocked to find out that they had written their entire codebase solely using broadcasting operations and in-built Julia functions.</p><p>Upon further reflection, I realized I needed to check my own biases. Broadcasting provides a hardware-agnostic method for performing almost any mathematical operation! If a user is exclusively crunching numbers, then there is almost no better abstraction than writing down the math and adding a few <code>.</code>s here and there.</p><p>Even so, after a few years, the ocean team sought even better performance and eventually rewrote their code using GPU-exclusive functions (kernels), which will be introduced in the following section. Simply put, broadcasting is an absolutely excellent way to get started with GPU computation in Julia. It&#39;s an intuitive abstraction and will get you <em>most</em> of the performance you need from the GPU.</p><p>But there&#39;s a reason this work is called the <em>GPU <strong>Kernel</strong> Handbook</em>. When you need true flexibility or performance, there is no better abstraction than writing functions specifically for the GPU.</p><h2 id="GPU-Functions:-Kernels"><a class="docs-heading-anchor" href="#GPU-Functions:-Kernels">GPU Functions: Kernels</a><a id="GPU-Functions:-Kernels-1"></a><a class="docs-heading-anchor-permalink" href="#GPU-Functions:-Kernels" title="Permalink"></a></h2><p>To recap, we have already introduced a language abstraction, known as <em>broadcasting</em>, that can be used out-of-the box in Julia for great GPU performance in most cases. We also walked through a simple example that used broadcasting to show the power of GPU computing with a 1000 times speed-up (on my hardware, at least) when compared to single-core CPU execution. This means that we should have some vague notion of how GPU execution works and what problems it&#39;s suited for, but now it&#39;s time to talk about the most common abstraction used for GPU programming: kernels.</p><p>Before going further, I think it&#39;s important to talk about the structure of this book. Simply put, almost every other chapter in this work will be related to writing and running kernels. This section is intended to provide the most basic level of understanding for kernel development in order to match what we have already discussed with broadcasting. Subsequent chapters will be much more thorough and build upon this knowledge.</p><p>In GPU programming, a <em>kernel</em> is a function specifically written to be run on the GPU for some computational task. In principle, the only difference between a kernel and a regular function is that kernels are meant to run in parallel on each core. This means that every core should run the <em>same, exact</em> function at the same time, but there are a few caveats to mention. For one, keep in mind that a lot of GPU computation will require more units of computation than there are cores. For example, a high-definition image might have 1920 x 1080 pixels in it. If the coloring or shading of each pixel is handled by a single core, then we would need 2,073,600 cores to do the computation. Unfortunately, the fastest GPUs in the world only have around 10,000 cores available. So what do we do? Well, <em>we</em> don&#39;t really worry about that and instead let a scheduler stage the computation to happen in groups of cores in parallel.</p><p>Keep in mind that kernels are abstractions. They are purposefully hiding information from users to make programming easier. In this case, users shouldn&#39;t need to think about the exact mechanics of scheduling on the GPU and can instead focus on writing down the specific computation that each core should perform. That said, programmers (like myself) are sometimes pedantic and will often distinguish terms a bit here. Instead of talking about &quot;cores,&quot; which are pieces of hardware, we often talk about &quot;work items&quot; (or &quot;threads&quot; for CUDA), which are abstract representations of cores to later be scheduled on to cores. To be clear, every work item corresponds to some core performing that computation, but we are letting the compiler choose <em>which</em> core each work item will run on. In this way, we don&#39;t need to worry about specifics of GPU hardware and can instead program them from a much more general perspective.</p><p>I think that&#39;s enough background info for now. In fact, it might be too much. Let&#39;s get to writing some kernels. To be clear, each GPU backend (CUDA, AMD, Metal, oneAPI) all provide their own kernel interfaces that work in Julia, but we will be using KernelAbstractions for this work, so we need to start by adding that package. Start by pressing <code>]</code> and then enter to enter package mode. Then:</p><pre><code class="nohighlight hljs">(@v1.10) pkg&gt; add KernelAbstractions</code></pre><p>Press enter. Install the library. Now we are ready to write our first GPU kernel.</p><h3 id="Vector-addition,-but-this-time-with-kernels."><a class="docs-heading-anchor" href="#Vector-addition,-but-this-time-with-kernels.">Vector addition, but this time with kernels.</a><a id="Vector-addition,-but-this-time-with-kernels.-1"></a><a class="docs-heading-anchor-permalink" href="#Vector-addition,-but-this-time-with-kernels." title="Permalink"></a></h3><p>Like I said before, vector addition is the &quot;Hello World!&quot; of GPU programming. It&#39;s one of the simplest units of computation that can be done on the GPU to test functionality. So, let&#39;s start by writing down a function that might add two elements of separate arrays together:</p><pre><code class="nohighlight hljs">function add!(c, a, b, idx)
    c[idx] = a[idx] + b[idx]
end</code></pre><p>This function will take in three arrays (<code>a</code>, <code>b</code>, and <code>c</code>) and add the <code>idx</code> index of <code>a</code> and <code>b</code> to the <code>idx</code> index of  <code>c</code>. So <code>add!(c, a, b, 1)</code> would be the same as <code>c[1] = a[1] + b[1]</code>. To be honest, it&#39;s a bit of a weird formulation, but bear with me. From here, it&#39;s relatively easy to transform the code into a GPU kernel that works on every work item (core). We just need to:</p><ol><li>Add <code>using KernelAbstractions</code> to the start of our script.</li><li>Add the <code>@kernel</code> macro to the start of our function.</li><li>Move the <code>idx</code> definition to inside the function with something like <code>idx = @index(Global)</code>, where <code>Global</code> signifies that we are pulling from all globally available threads.</li></ol><div class="admonition is-success"><header class="admonition-header">What&#39;s the exclamation point (`!`) for?</header><div class="admonition-body"><p>In programming, there is a concept known as &quot;mutation&quot; that indicates an in-place change to the values of an array or structure. For example, setting <code>a[1] = 5</code> <em>mutates</em> <code>a</code>. It changes a single element, but <code>a</code> is still the same size and shape it was before. In Julia, functions can also mutate data, such as in <code>add!(c, a, b, idx)</code> above. In these cases, it is good practice (though not a requirement) to notate the function with an exclamation point (<code>!</code>). It&#39;s also common to put the array(s) that will be mutated at the start of the argument list, which is why we set the order of <code>add!</code> to be <code>c, a, b</code> instead of <code>a, b, c</code>. At the end of the day, these are just small notational changes to help other people understand how your code works. It&#39;s up to you whether they make sense in your, specific context.</p></div></div><pre><code class="nohighlight hljs">using KernelAbstractions

@kernel function add!(c, a, b)
    idx = @index(Global)
    c[idx] = a[idx] + b[idx]
end</code></pre><p>And that&#39;s the whole function. Now we just need to run it. This is generally done in 3 steps:</p><ol><li>Configure all the input variables. In this case, it would mean making sure that <code>a</code>, <code>b</code>, and <code>c</code> are all of the appropriate array type for running the code on the GPU or in parallel on the CPU with the generic <code>Array</code> type.</li><li>Configure the kernel. This is done by first getting the right backend (for example, AMD, NVIDIA, Metal, etc), and then running the kernel with that backend as a function argument, so <code>kernel = add!(get_backend(a))</code>.</li><li>Run the kernel with the appropriate arguments, so <code>kernel(c, a, b, ndrange = length(a))</code>. Here <code>ndrange</code> is an <span>$n$</span>-dimensional range of values to index over. In this case, as long as <code>a</code>, <code>b</code>, and <code>c</code> are all the same length, we can set the range to be the <code>length(...)</code> of any of the three.</li></ol><p>Putting all of that together:</p><pre><code class="nohighlight hljs">a = ArrayType(rand(10))
b = ArrayType(rand(10))
c = similar(a)

backend = get_backend(a)
kernel = add!(backend)
kernel(c, a, b; ndrange = length(a))</code></pre><p>After running this, <code>c</code> should be <code>a .+ b</code>. Actually, now is a perfect time to test our results, so let&#39;s do that by comparing the results to broadcasting:</p><pre><code class="nohighlight hljs">using Test

@test c == a .+ b
</code></pre><p>Running this should return <code>Test Passed</code> into the REPL. And that&#39;s all there is to it. Your first GPU kernel.</p><p>Take a second to breath and pat yourself on the back a bit. At this point in time, you have taken a bold step into the world of GPU computing. There are a lot of specifics to talk about from here, but for many tasks, this level of GPU understanding is already enough to start seeing some benefits from the GPU. That said, there is still a lot left to do and many more pages in this book, so I do hope you keep reading to learn more.</p><div class="admonition is-todo"><header class="admonition-header">Problem 9: Do it on your machine</header><div class="admonition-body"><p>In case you haven&#39;t done it already, it is important to do this exercise on your own machine to make sure you understand how everything is put together. Basically, add <code>a</code> and <code>b</code> and make sure the results match what you expected from the broadcasting results.</p></div></div><div class="admonition is-todo"><header class="admonition-header">Problem 10: Set each array element equal to it&#39;s index</header><div class="admonition-body"><p>Create a simple kernel that sets every element of an array equal to it&#39;s index (<code>idx = @index(Global)</code> in the previous example)</p></div></div><div class="admonition is-todo"><header class="admonition-header">Problem 11: Create a sine wave</header><div class="admonition-body"><p>Create a simple kernel that creates a sine wave when plotting. Then pass it back to the CPU and plot it with <code>plot(...)</code> from the <code>Plots</code> package.</p><p>Hint: You instead of setting each element of the array equal to it&#39;s index, set it to some value between 0 and 2<em>pi and then pass that in to a sin function. In the end, it might look like this: `sin(idx / (2</em>pi))`.</p></div></div><div class="admonition is-todo"><header class="admonition-header">Problem 12: Add half of an array to another array</header><div class="admonition-body"><p>Create two arrays and add the first half of one to the second half of the other. This involves creating a custom <code>ndrange</code> that might be something like <code>length(a)/2</code> where <code>a</code> is one of your arrays.</p></div></div><div class="admonition is-info"><header class="admonition-header">Reviewer&#39;s Notice</header><div class="admonition-body"><p>Again, looking for more problems.</p></div></div><h2 id="A-discussion-on-loop-vectorization"><a class="docs-heading-anchor" href="#A-discussion-on-loop-vectorization">A discussion on loop vectorization</a><a id="A-discussion-on-loop-vectorization-1"></a><a class="docs-heading-anchor-permalink" href="#A-discussion-on-loop-vectorization" title="Permalink"></a></h2><p>At this point in time, we have introduced two separate abstractions for GPU computing: broadcasting and kernels. We have discussed several core benefits of both, but I acknowledge that neither one is common outside of specific circles. There is yet another abstraction commonly used for GPU programming. One that everyone knows (and many people love). They are one of the first things people learn how to do in any new programming language and are essential tools for almost any workflow. Yes, I&#39;m talking about loops.</p><p>On paper, loops look like perfect abstractions for parallel computing. After all, they iterate through a list. It should be entirely possible to distribute that work to multiple cores, so that (for instance) core 1 handles iteration 1 and core 4 handles iteration 4. In fact, this is precisely what loop vectorization is, and there are plenty of GPU libraries that use loop vectorization for various GPU backends. That said, these libraries require users to modify their loops in some way for them to run at all on the GPU.</p><p>Simply put, the following code will fail due to the scalar indexing issue brought up before:</p><pre><code class="nohighlight hljs">julia&gt; a = ArrayType(zeros(10));

julia&gt; for i = 1:10
           a[i] = 1
       end
ERROR: Scalar indexing is disallowed.
Invocation of setindex! resulted in scalar indexing of a GPU array.
This is typically caused by calling an iterating implementation of a method.
Such implementations *do not* execute on the GPU, but very slowly on the CPU,
and therefore should be avoided.

If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`
to enable scalar iteration globally or for the operations in question.
Stacktrace:
 [1] error(s::String)
   @ Base ./error.jl:35
 [2] errorscalar(op::String)
   @ GPUArraysCore ~/.julia/packages/GPUArraysCore/aNaXo/src/GPUArraysCore.jl:151
 [3] _assertscalar(op::String, behavior::GPUArraysCore.ScalarIndexing)
   @ GPUArraysCore ~/.julia/packages/GPUArraysCore/aNaXo/src/GPUArraysCore.jl:124
 [4] assertscalar(op::String)
   @ GPUArraysCore ~/.julia/packages/GPUArraysCore/aNaXo/src/GPUArraysCore.jl:112
 [5] setindex!(A::ROCArray{Float64, 1, AMDGPU.Runtime.Mem.HIPBuffer}, v::Int64, I::Int64)
   @ GPUArrays ~/.julia/packages/GPUArrays/Mot2g/src/host/indexing.jl:58
 [6] top-level scope
   @ ./REPL[13]:2</code></pre><p>There is no functional difference between <code>a[i]</code> and <code>a[1]</code>. In both cases, we are trying to manipulate a single element of a GPU array, which we have already indicated is a problem. So how do we modify the code to run in parallel? Well, here is a parallel, CPU <code>for</code> loop in Julia:</p><pre><code class="nohighlight hljs">Threads.@threads for i = 1:10
    println(i)
end</code></pre><p>Note that to use this loop, we need to launch Julia with a certain number of threads, such as <code>julia -t 12</code> for 12 threads. After, all we need to do is add the <code>@threads</code> macro from the <code>Threads</code> package to the start of the loop. At a glance, it looks incredibly straightforward. After all, we can just add a macro to the start of the loop without modifying anything else in the code. But now let&#39;s look at the output for single core and parallel execution:</p><table><tr><th style="text-align: right">single-core</th><th style="text-align: right">parallel</th></tr><tr><td style="text-align: right">1</td><td style="text-align: right">2</td></tr><tr><td style="text-align: right">2</td><td style="text-align: right">1</td></tr><tr><td style="text-align: right">3</td><td style="text-align: right">10</td></tr><tr><td style="text-align: right">4</td><td style="text-align: right">8</td></tr><tr><td style="text-align: right">5</td><td style="text-align: right">5</td></tr><tr><td style="text-align: right">6</td><td style="text-align: right">9</td></tr><tr><td style="text-align: right">7</td><td style="text-align: right">3</td></tr><tr><td style="text-align: right">8</td><td style="text-align: right">4</td></tr><tr><td style="text-align: right">9</td><td style="text-align: right">7</td></tr><tr><td style="text-align: right">10</td><td style="text-align: right">6</td></tr></table><p>The single core results look great, but the parallel ones are all jumbled up! Why? Well because the single core loop executed iteratively while the parallel loop executed in parallel. This means that each <code>println(i)</code> statement was given to a different CPU core. If the core was slightly faster (as in core <code>2</code>), it printed first. If the core was slightly slower (as in core <code>6</code>), it printed last. If the core was somewhere in the middle, it printed out somewhere in the middle. For parallel loops, the output order is independent of the iterative count between 1 and 10.</p><p>I remember when I saw this for the first time, I was surprised. In my mind, it shouldn&#39;t have mattered when the cores finished their operations. The <code>for</code> loop should have just output everything in the right order, regardless of when the computation was done! But upon further reflection, I realized my own perspective was naive.</p><p>The fact is that <code>Threads.@threads</code> is fundamentally changing the loop into something completely different. We can&#39;t just slap that bad boy on anything. When we use <code>Threads.@threads</code>, we need to think about the ramifications of parallelism in the very same way we would think about writing complex kernels and distributing work to different GPU cores. It&#39;s just now we <em>also</em> need to fight our own intuition on how these loops should function.</p><p>So how might we modify the loop to output the numbers in order? The simplest way would be to introduce an array so each core is not simply printing a number, but instead modifying a particular element of the array. Core 1 might modify index 1. Core 2 might modify index 2. And so on. In the end, it might look something like this:</p><pre><code class="nohighlight hljs">a = zeros(10)
Threads.@threads for i = 1:length(a)
    a[i] = i
end
println(a)</code></pre><p>This will print the elements of the array in order because each core was given some ordered location to put the data in. Note that to get this loop to do what we wanted in the end, we needed to introduce an auxiliary array and then modify our operation to act on that data. This is precisely the same workflow as broadcasting and kernels, so even though we are &quot;just adding a macro to the start of the loop,&quot; we also have to fundamentally change the structure of our code to get the macro to work. In my experience, this is generally true. Loops appear easy to new programmers, but are actually not always intuitive abstractions for parallel programming.</p><p>Another problem with looping is that many loops are inherently iterative and cannot be easily parallelized. Take timestepping, for example (the act of simulating motion, one small time step at a time). In this case, each iteration is a point in time, so the first step (<code>i = 1</code>) <em>must</em> come before <code>i = 2</code>, which must come before <code>i = 3</code>, and so on. There is no issue with iterative methods like timestepping when we are running code on a single core of a CPU, but let&#39;s face it: basically no one is currently writing code for a single-core CPU because such computers essentially don&#39;t exist. Nowadays, we really do care about parallelism. <code>Threads.@threads</code> (or similar approaches from other languages) feels a bandage solution to transform an iterative method into a parallel one which can be misleading for students and programmers.</p><p>In addition, by relying on loops for parallelism, the code ends up being a large set of nested <code>for</code> loops, with one set of loops somewhere in the middle being parallel, while the rest remain iterative. It can quickly become a huge mess. While it is usually quite clear how to parallelize kernels, the choice of <em>which</em> loop to parallelize over is sometimes difficult for beginner programmers. At least in my experience, I have found that codebases using parallel loops end up looking just as messy, if not messier, than code using kernel-based approaches. On the other hand, for programmers that know what they are doing, loop-based abstractions can still be quite helpful – especially for code that already exists and would be a pain to rewrite. There are also GPU interfaces (like Kokkos and SyCL) that use parallel loops by default.</p><p>Unfortunately, for all the reasons mentioned here, there is not strong library support for loop vectorization on the GPU in Julia, though there have been many attempts. If you absolutely need a loop-based abstraction for parallel GPU programming in Julia, I would recommend looking into GPUifyLoops.jl, Floops.jl, or JACC.jl. By the time you are reading this, there might be another solution that exists as well.</p><p>To wrap up my thoughts on looping as a useful abstraction for GPU computing, I&#39;ll say this. The most popular language for GPGPU today is CUDA, and it uses kernels exclusively. I love broadcasting, but acknowledge it is essentially never used outside of niche applications. A lot of computer scientists still believe loops are the answer. But if we are looking at the numbers, it&#39;s incredibly clear that kernels have won the GPU abstraction wars, and for good reason. Kernels are more flexible than loops and are often more straightforward to write and integrate into a pre-existing software project. It feels like loop vectorization exists as a olive branch to traditional CPU programmers who are unwilling to change their code to better reflect the world around them.</p><p>Ok. I think this is a good place to stop rambling. We covered all the basics necessary for the rest of this text. In the following chapters, we will begin to dive deeply into all the different things we can do with GPU kernels, starting with the most trivial stumbling block: summation.</p><div class="admonition is-info"><header class="admonition-header">Reviewer&#39;s Notice</header><div class="admonition-body"><p>Again looking for general problem sets for readers to go through. I&#39;ll be fleshing this out later as the future directions become more clear.</p></div></div><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>https://julialang.org/downloads/</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>https://code.visualstudio.com/docs/languages/julia](https://code.visualstudio.com/docs/languages/julia</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../intro/">« Introduction</a><a class="docs-footer-nextpage" href="../../scribbleios/">Welcome »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Friday 4 July 2025 09:25">Friday 4 July 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
